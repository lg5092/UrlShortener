"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterValues = exports.TemplateParameters = exports.CloudFormationStack = void 0;
exports.waitForChangeSet = waitForChangeSet;
exports.createDiffChangeSet = createDiffChangeSet;
exports.uploadStackTemplateAssets = uploadStackTemplateAssets;
exports.createChangeSet = createChangeSet;
exports.changeSetHasNoChanges = changeSetHasNoChanges;
exports.waitForStackDelete = waitForStackDelete;
exports.waitForStackDeploy = waitForStackDeploy;
exports.stabilizeStack = stabilizeStack;
const util_1 = require("util");
const cxapi = require("@aws-cdk/cx-api");
const cx_api_1 = require("@aws-cdk/cx-api");
const client_cloudformation_1 = require("@aws-sdk/client-cloudformation");
const cdk_assets_1 = require("cdk-assets");
const asset_manifest_builder_1 = require("./asset-manifest-builder");
const messages_1 = require("../../cli/messages");
const error_1 = require("../../toolkit/error");
const format_error_1 = require("../../util/format-error");
const serialize_1 = require("../../util/serialize");
const stack_events_1 = require("../stack-events");
const template_body_parameter_1 = require("../util/template-body-parameter");
/**
 * Represents an (existing) Stack in CloudFormation
 *
 * Bundle and cache some information that we need during deployment (so we don't have to make
 * repeated calls to CloudFormation).
 */
class CloudFormationStack {
    static async lookup(cfn, stackName, retrieveProcessedTemplate = false) {
        try {
            const response = await cfn.describeStacks({ StackName: stackName });
            return new CloudFormationStack(cfn, stackName, response.Stacks && response.Stacks[0], retrieveProcessedTemplate);
        }
        catch (e) {
            if (e.name === 'ValidationError' && (0, format_error_1.formatErrorMessage)(e) === `Stack with id ${stackName} does not exist`) {
                return new CloudFormationStack(cfn, stackName, undefined);
            }
            throw e;
        }
    }
    /**
     * Return a copy of the given stack that does not exist
     *
     * It's a little silly that it needs arguments to do that, but there we go.
     */
    static doesNotExist(cfn, stackName) {
        return new CloudFormationStack(cfn, stackName);
    }
    /**
     * From static information (for testing)
     */
    static fromStaticInformation(cfn, stackName, stack) {
        return new CloudFormationStack(cfn, stackName, stack);
    }
    constructor(cfn, stackName, stack, retrieveProcessedTemplate = false) {
        this.cfn = cfn;
        this.stackName = stackName;
        this.stack = stack;
        this.retrieveProcessedTemplate = retrieveProcessedTemplate;
    }
    /**
     * Retrieve the stack's deployed template
     *
     * Cached, so will only be retrieved once. Will return an empty
     * structure if the stack does not exist.
     */
    async template() {
        if (!this.exists) {
            return {};
        }
        if (this._template === undefined) {
            const response = await this.cfn.getTemplate({
                StackName: this.stackName,
                TemplateStage: this.retrieveProcessedTemplate ? 'Processed' : 'Original',
            });
            this._template = (response.TemplateBody && (0, serialize_1.deserializeStructure)(response.TemplateBody)) || {};
        }
        return this._template;
    }
    /**
     * Whether the stack exists
     */
    get exists() {
        return this.stack !== undefined;
    }
    /**
     * The stack's ID
     *
     * Throws if the stack doesn't exist.
     */
    get stackId() {
        this.assertExists();
        return this.stack.StackId;
    }
    /**
     * The stack's current outputs
     *
     * Empty object if the stack doesn't exist
     */
    get outputs() {
        if (!this.exists) {
            return {};
        }
        const result = {};
        (this.stack.Outputs || []).forEach((output) => {
            result[output.OutputKey] = output.OutputValue;
        });
        return result;
    }
    /**
     * The stack's status
     *
     * Special status NOT_FOUND if the stack does not exist.
     */
    get stackStatus() {
        if (!this.exists) {
            return new stack_events_1.StackStatus('NOT_FOUND', 'Stack not found during lookup');
        }
        return stack_events_1.StackStatus.fromStackDescription(this.stack);
    }
    /**
     * The stack's current tags
     *
     * Empty list if the stack does not exist
     */
    get tags() {
        var _a;
        return ((_a = this.stack) === null || _a === void 0 ? void 0 : _a.Tags) || [];
    }
    /**
     * SNS Topic ARNs that will receive stack events.
     *
     * Empty list if the stack does not exist
     */
    get notificationArns() {
        var _a, _b;
        return (_b = (_a = this.stack) === null || _a === void 0 ? void 0 : _a.NotificationARNs) !== null && _b !== void 0 ? _b : [];
    }
    /**
     * Return the names of all current parameters to the stack
     *
     * Empty list if the stack does not exist.
     */
    get parameterNames() {
        return Object.keys(this.parameters);
    }
    /**
     * Return the names and values of all current parameters to the stack
     *
     * Empty object if the stack does not exist.
     */
    get parameters() {
        var _a, _b;
        if (!this.exists) {
            return {};
        }
        const ret = {};
        for (const param of (_a = this.stack.Parameters) !== null && _a !== void 0 ? _a : []) {
            ret[param.ParameterKey] = (_b = param.ResolvedValue) !== null && _b !== void 0 ? _b : param.ParameterValue;
        }
        return ret;
    }
    /**
     * Return the termination protection of the stack
     */
    get terminationProtection() {
        var _a;
        return (_a = this.stack) === null || _a === void 0 ? void 0 : _a.EnableTerminationProtection;
    }
    assertExists() {
        if (!this.exists) {
            throw new error_1.ToolkitError(`No stack named '${this.stackName}'`);
        }
    }
}
exports.CloudFormationStack = CloudFormationStack;
/**
 * Describe a changeset in CloudFormation, regardless of its current state.
 *
 * @param cfn           a CloudFormation client
 * @param stackName     the name of the Stack the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 * @param fetchAll      if true, fetches all pages of the change set description.
 *
 * @returns       CloudFormation information about the ChangeSet
 */
async function describeChangeSet(cfn, stackName, changeSetName, { fetchAll }) {
    var _a;
    const response = await cfn.describeChangeSet({
        StackName: stackName,
        ChangeSetName: changeSetName,
    });
    // If fetchAll is true, traverse all pages from the change set description.
    while (fetchAll && response.NextToken != null) {
        const nextPage = await cfn.describeChangeSet({
            StackName: stackName,
            ChangeSetName: (_a = response.ChangeSetId) !== null && _a !== void 0 ? _a : changeSetName,
            NextToken: response.NextToken,
        });
        // Consolidate the changes
        if (nextPage.Changes != null) {
            response.Changes = response.Changes != null ? response.Changes.concat(nextPage.Changes) : nextPage.Changes;
        }
        // Forward the new NextToken
        response.NextToken = nextPage.NextToken;
    }
    return response;
}
/**
 * Waits for a function to return non-+undefined+ before returning.
 *
 * @param valueProvider a function that will return a value that is not +undefined+ once the wait should be over
 * @param timeout     the time to wait between two calls to +valueProvider+
 *
 * @returns       the value that was returned by +valueProvider+
 */
async function waitFor(valueProvider, timeout = 5000) {
    while (true) {
        const result = await valueProvider();
        if (result === null) {
            return undefined;
        }
        else if (result !== undefined) {
            return result;
        }
        await new Promise((cb) => setTimeout(cb, timeout));
    }
}
/**
 * Waits for a ChangeSet to be available for triggering a StackUpdate.
 *
 * Will return a changeset that is either ready to be executed or has no changes.
 * Will throw in other cases.
 *
 * @param cfn           a CloudFormation client
 * @param stackName     the name of the Stack that the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 * @param fetchAll      if true, fetches all pages of the ChangeSet before returning.
 *
 * @returns       the CloudFormation description of the ChangeSet
 */
async function waitForChangeSet(cfn, { ioHost, action }, stackName, changeSetName, { fetchAll }) {
    await ioHost.notify((0, messages_1.debug)(action, (0, util_1.format)('Waiting for changeset %s on stack %s to finish creating...', changeSetName, stackName)));
    const ret = await waitFor(async () => {
        const description = await describeChangeSet(cfn, stackName, changeSetName, {
            fetchAll,
        });
        // The following doesn't use a switch because tsc will not allow fall-through, UNLESS it is allows
        // EVERYWHERE that uses this library directly or indirectly, which is undesirable.
        if (description.Status === 'CREATE_PENDING' || description.Status === 'CREATE_IN_PROGRESS') {
            await ioHost.notify((0, messages_1.debug)(action, (0, util_1.format)('Changeset %s on stack %s is still creating', changeSetName, stackName)));
            return undefined;
        }
        if (description.Status === client_cloudformation_1.ChangeSetStatus.CREATE_COMPLETE || changeSetHasNoChanges(description)) {
            return description;
        }
        // eslint-disable-next-line max-len
        throw new error_1.ToolkitError(`Failed to create ChangeSet ${changeSetName} on ${stackName}: ${description.Status || 'NO_STATUS'}, ${description.StatusReason || 'no reason provided'}`);
    });
    if (!ret) {
        throw new error_1.ToolkitError('Change set took too long to be created; aborting');
    }
    return ret;
}
/**
 * Create a changeset for a diff operation
 */
async function createDiffChangeSet({ ioHost, action }, options) {
    var _a;
    // `options.stack` has been modified to include any nested stack templates directly inline with its own template, under a special `NestedTemplate` property.
    // Thus the parent template's Resources section contains the nested template's CDK metadata check, which uses Fn::Equals.
    // This causes CreateChangeSet to fail with `Template Error: Fn::Equals cannot be partially collapsed`.
    for (const resource of Object.values((_a = options.stack.template.Resources) !== null && _a !== void 0 ? _a : {})) {
        if (resource.Type === 'AWS::CloudFormation::Stack') {
            await ioHost.notify((0, messages_1.debug)(action, 'This stack contains one or more nested stacks, falling back to template-only diff...'));
            return undefined;
        }
    }
    return uploadBodyParameterAndCreateChangeSet({ ioHost, action }, options);
}
/**
 * Returns all file entries from an AssetManifestArtifact that look like templates.
 *
 * This is used in the `uploadBodyParameterAndCreateChangeSet` function to find
 * all template asset files to build and publish.
 *
 * Returns a tuple of [AssetManifest, FileManifestEntry[]]
 */
function templatesFromAssetManifestArtifact(artifact) {
    const assets = [];
    const fileName = artifact.file;
    const assetManifest = cdk_assets_1.AssetManifest.fromFile(fileName);
    assetManifest.entries.forEach((entry) => {
        if (entry.type === 'file') {
            const source = entry.source;
            if (source.path && source.path.endsWith('.template.json')) {
                assets.push(entry);
            }
        }
    });
    return [assetManifest, assets];
}
async function uploadBodyParameterAndCreateChangeSet({ ioHost, action }, options) {
    try {
        await uploadStackTemplateAssets(options.stack, options.deployments);
        const env = await options.deployments.envs.accessStackForMutableStackOperations(options.stack);
        const bodyParameter = await (0, template_body_parameter_1.makeBodyParameter)(options.stack, env.resolvedEnvironment, new asset_manifest_builder_1.AssetManifestBuilder(), env.resources);
        const cfn = env.sdk.cloudFormation();
        const exists = (await CloudFormationStack.lookup(cfn, options.stack.stackName, false)).exists;
        const executionRoleArn = await env.replacePlaceholders(options.stack.cloudFormationExecutionRoleArn);
        options.stream.write('Hold on while we create a read-only change set to get a diff with accurate replacement information (use --no-change-set to use a less accurate but faster template-only diff)\n');
        return await createChangeSet({ ioHost, action }, {
            cfn,
            changeSetName: 'cdk-diff-change-set',
            stack: options.stack,
            exists,
            uuid: options.uuid,
            willExecute: options.willExecute,
            bodyParameter,
            parameters: options.parameters,
            resourcesToImport: options.resourcesToImport,
            role: executionRoleArn,
        });
    }
    catch (e) {
        await ioHost.notify((0, messages_1.debug)(action, e));
        options.stream.write('Could not create a change set, will base the diff on template differences (run again with -v to see the reason)\n');
        return undefined;
    }
}
/**
 * Uploads the assets that look like templates for this CloudFormation stack
 *
 * This is necessary for any CloudFormation call that needs the template, it may need
 * to be uploaded to an S3 bucket first. We have to follow the instructions in the
 * asset manifest, because technically that is the only place that knows about
 * bucket and assumed roles and such.
 */
async function uploadStackTemplateAssets(stack, deployments) {
    for (const artifact of stack.dependencies) {
        // Skip artifact if it is not an Asset Manifest Artifact
        if (!cxapi.AssetManifestArtifact.isAssetManifestArtifact(artifact)) {
            continue;
        }
        const [assetManifest, file_entries] = templatesFromAssetManifestArtifact(artifact);
        for (const entry of file_entries) {
            await deployments.buildSingleAsset(artifact, assetManifest, entry, {
                stack,
            });
            await deployments.publishSingleAsset(assetManifest, entry, {
                stack,
            });
        }
    }
}
async function createChangeSet({ ioHost, action }, options) {
    await cleanupOldChangeset(options.cfn, { ioHost, action }, options.changeSetName, options.stack.stackName);
    await ioHost.notify((0, messages_1.debug)(action, `Attempting to create ChangeSet with name ${options.changeSetName} for stack ${options.stack.stackName}`));
    const templateParams = TemplateParameters.fromTemplate(options.stack.template);
    const stackParams = templateParams.supplyAll(options.parameters);
    const changeSet = await options.cfn.createChangeSet({
        StackName: options.stack.stackName,
        ChangeSetName: options.changeSetName,
        ChangeSetType: options.resourcesToImport ? 'IMPORT' : options.exists ? 'UPDATE' : 'CREATE',
        Description: `CDK Changeset for diff ${options.uuid}`,
        ClientToken: `diff${options.uuid}`,
        TemplateURL: options.bodyParameter.TemplateURL,
        TemplateBody: options.bodyParameter.TemplateBody,
        Parameters: stackParams.apiParameters,
        ResourcesToImport: options.resourcesToImport,
        RoleARN: options.role,
        Tags: toCfnTags(options.stack.tags),
        Capabilities: ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM', 'CAPABILITY_AUTO_EXPAND'],
    });
    await ioHost.notify((0, messages_1.debug)(action, (0, util_1.format)('Initiated creation of changeset: %s; waiting for it to finish creating...', changeSet.Id)));
    // Fetching all pages if we'll execute, so we can have the correct change count when monitoring.
    const createdChangeSet = await waitForChangeSet(options.cfn, { ioHost, action }, options.stack.stackName, options.changeSetName, {
        fetchAll: options.willExecute,
    });
    await cleanupOldChangeset(options.cfn, { ioHost, action }, options.changeSetName, options.stack.stackName);
    return createdChangeSet;
}
function toCfnTags(tags) {
    return Object.entries(tags).map(([k, v]) => ({
        Key: k,
        Value: v,
    }));
}
async function cleanupOldChangeset(cfn, { ioHost, action }, changeSetName, stackName) {
    // Delete any existing change sets generated by CDK since change set names must be unique.
    // The delete request is successful as long as the stack exists (even if the change set does not exist).
    await ioHost.notify((0, messages_1.debug)(action, `Removing existing change set with name ${changeSetName} if it exists`));
    await cfn.deleteChangeSet({
        StackName: stackName,
        ChangeSetName: changeSetName,
    });
}
/**
 * Return true if the given change set has no changes
 *
 * This must be determined from the status, not the 'Changes' array on the
 * object; the latter can be empty because no resources were changed, but if
 * there are changes to Outputs, the change set can still be executed.
 */
function changeSetHasNoChanges(description) {
    const noChangeErrorPrefixes = [
        // Error message for a regular template
        "The submitted information didn't contain changes.",
        // Error message when a Transform is involved (see #10650)
        'No updates are to be performed.',
    ];
    return (description.Status === 'FAILED' && noChangeErrorPrefixes.some((p) => { var _a; return ((_a = description.StatusReason) !== null && _a !== void 0 ? _a : '').startsWith(p); }));
}
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after a delete operation is issued.
 *
 * Fails if the stack is in a FAILED state. Will not fail if the stack was
 * already deleted.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after a delete
 *
 * @returns     the CloudFormation description of the stabilized stack after the delete attempt
 */
async function waitForStackDelete(cfn, { ioHost, action }, stackName) {
    const stack = await stabilizeStack(cfn, { ioHost, action }, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isFailure) {
        throw new error_1.ToolkitError(`The stack named ${stackName} is in a failed state. You may need to delete it from the AWS console : ${status}`);
    }
    else if (status.isDeleted) {
        return undefined;
    }
    return stack;
}
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after an update/create operation is issued.
 *
 * Fails if the stack is in a FAILED state, ROLLBACK state, or DELETED state.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after an update
 *
 * @returns     the CloudFormation description of the stabilized stack after the update attempt
 */
async function waitForStackDeploy(cfn, { ioHost, action }, stackName) {
    const stack = await stabilizeStack(cfn, { ioHost, action }, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isCreationFailure) {
        throw new error_1.ToolkitError(`The stack named ${stackName} failed creation, it may need to be manually deleted from the AWS console: ${status}`);
    }
    else if (!status.isDeploySuccess) {
        throw new error_1.ToolkitError(`The stack named ${stackName} failed to deploy: ${status}`);
    }
    return stack;
}
/**
 * Wait for a stack to become stable (no longer _IN_PROGRESS), returning it
 */
async function stabilizeStack(cfn, { ioHost, action }, stackName) {
    await ioHost.notify((0, messages_1.debug)(action, (0, util_1.format)('Waiting for stack %s to finish creating or updating...', stackName)));
    return waitFor(async () => {
        const stack = await CloudFormationStack.lookup(cfn, stackName);
        if (!stack.exists) {
            await ioHost.notify((0, messages_1.debug)(action, (0, util_1.format)('Stack %s does not exist', stackName)));
            return null;
        }
        const status = stack.stackStatus;
        if (status.isInProgress) {
            await ioHost.notify((0, messages_1.debug)(action, (0, util_1.format)('Stack %s has an ongoing operation in progress and is not stable (%s)', stackName, status)));
            return undefined;
        }
        else if (status.isReviewInProgress) {
            // This may happen if a stack creation operation is interrupted before the ChangeSet execution starts. Recovering
            // from this would requiring manual intervention (deleting or executing the pending ChangeSet), and failing to do
            // so will result in an endless wait here (the ChangeSet wont delete or execute itself). Instead of blocking
            // "forever" we proceed as if the stack was existing and stable. If there is a concurrent operation that just
            // hasn't finished proceeding just yet, either this operation or the concurrent one may fail due to the other one
            // having made progress. Which is fine. I guess.
            await ioHost.notify((0, messages_1.debug)(action, (0, util_1.format)('Stack %s is in REVIEW_IN_PROGRESS state. Considering this is a stable status (%s)', stackName, status)));
        }
        return stack;
    });
}
/**
 * The set of (formal) parameters that have been declared in a template
 */
class TemplateParameters {
    static fromTemplate(template) {
        return new TemplateParameters(template.Parameters || {});
    }
    constructor(params) {
        this.params = params;
    }
    /**
     * Calculate stack parameters to pass from the given desired parameter values
     *
     * Will throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    supplyAll(updates) {
        return new ParameterValues(this.params, updates);
    }
    /**
     * From the template, the given desired values and the current values, calculate the changes to the stack parameters
     *
     * Will take into account parameters already set on the template (will emit
     * 'UsePreviousValue: true' for those unless the value is changed), and will
     * throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    updateExisting(updates, previousValues) {
        return new ParameterValues(this.params, updates, previousValues);
    }
}
exports.TemplateParameters = TemplateParameters;
/**
 * The set of parameters we're going to pass to a Stack
 */
class ParameterValues {
    constructor(formalParams, updates, previousValues = {}) {
        this.formalParams = formalParams;
        this.values = {};
        this.apiParameters = [];
        const missingRequired = new Array();
        for (const [key, formalParam] of Object.entries(this.formalParams)) {
            // Check updates first, then use the previous value (if available), then use
            // the default (if available).
            //
            // If we don't find a parameter value using any of these methods, then that's an error.
            const updatedValue = updates[key];
            if (updatedValue !== undefined) {
                this.values[key] = updatedValue;
                this.apiParameters.push({
                    ParameterKey: key,
                    ParameterValue: updates[key],
                });
                continue;
            }
            if (key in previousValues) {
                this.values[key] = previousValues[key];
                this.apiParameters.push({ ParameterKey: key, UsePreviousValue: true });
                continue;
            }
            if (formalParam.Default !== undefined) {
                this.values[key] = formalParam.Default;
                continue;
            }
            // Oh no
            missingRequired.push(key);
        }
        if (missingRequired.length > 0) {
            throw new error_1.ToolkitError(`The following CloudFormation Parameters are missing a value: ${missingRequired.join(', ')}`);
        }
        // Just append all supplied overrides that aren't really expected (this
        // will fail CFN but maybe people made typos that they want to be notified
        // of)
        const unknownParam = ([key, _]) => this.formalParams[key] === undefined;
        const hasValue = ([_, value]) => !!value;
        for (const [key, value] of Object.entries(updates).filter(unknownParam).filter(hasValue)) {
            this.values[key] = value;
            this.apiParameters.push({ ParameterKey: key, ParameterValue: value });
        }
    }
    /**
     * Whether this set of parameter updates will change the actual stack values
     */
    hasChanges(currentValues) {
        // If any of the parameters are SSM parameters, deploying must always happen
        // because we can't predict what the values will be. We will allow some
        // parameters to opt out of this check by having a magic string in their description.
        if (Object.values(this.formalParams).some((p) => { var _a; return p.Type.startsWith('AWS::SSM::Parameter::') && !((_a = p.Description) === null || _a === void 0 ? void 0 : _a.includes(cx_api_1.SSMPARAM_NO_INVALIDATE)); })) {
            return 'ssm';
        }
        // Otherwise we're dirty if:
        // - any of the existing values are removed, or changed
        if (Object.entries(currentValues).some(([key, value]) => !(key in this.values) || value !== this.values[key])) {
            return true;
        }
        // - any of the values we're setting are new
        if (Object.keys(this.values).some((key) => !(key in currentValues))) {
            return true;
        }
        return false;
    }
}
exports.ParameterValues = ParameterValues;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZGZvcm1hdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFpU0EsNENBa0NDO0FBNkJELGtEQWdCQztBQWdGRCw4REFpQkM7QUFFRCwwQ0FrQ0M7QUErQkQsc0RBV0M7QUFjRCxnREFtQkM7QUFhRCxnREFxQkM7QUFLRCx3Q0EyQkM7QUFsb0JELCtCQUE4QjtBQUM5Qix5Q0FBeUM7QUFDekMsNENBQXlEO0FBQ3pELDBFQVF3QztBQUN4QywyQ0FBOEQ7QUFDOUQscUVBQWdFO0FBRWhFLGlEQUEyQztBQUUzQywrQ0FBbUQ7QUFDbkQsMERBQTZEO0FBQzdELG9EQUE0RDtBQUU1RCxrREFBOEM7QUFDOUMsNkVBQTJGO0FBa0IzRjs7Ozs7R0FLRztBQUNILE1BQWEsbUJBQW1CO0lBQ3ZCLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUN4QixHQUEwQixFQUMxQixTQUFpQixFQUNqQiw0QkFBcUMsS0FBSztRQUUxQyxJQUFJLENBQUM7WUFDSCxNQUFNLFFBQVEsR0FBRyxNQUFNLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQztZQUNwRSxPQUFPLElBQUksbUJBQW1CLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxRQUFRLENBQUMsTUFBTSxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUseUJBQXlCLENBQUMsQ0FBQztRQUNuSCxDQUFDO1FBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztZQUNoQixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssaUJBQWlCLElBQUksSUFBQSxpQ0FBa0IsRUFBQyxDQUFDLENBQUMsS0FBSyxpQkFBaUIsU0FBUyxpQkFBaUIsRUFBRSxDQUFDO2dCQUMxRyxPQUFPLElBQUksbUJBQW1CLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUM1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RyxFQUNELENBQUM7WUFDRCxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCw0QkFBNEI7UUFDNUIsdURBQXVEO1FBQ3ZELElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQzlHLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELDRDQUE0QztRQUM1QyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDcEUsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUFwRkQsMENBb0ZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgU1NNUEFSQU1fTk9fSU5WQUxJREFURSB9IGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQge1xuICBDaGFuZ2VTZXRTdGF0dXMsXG4gIHR5cGUgRGVzY3JpYmVDaGFuZ2VTZXRDb21tYW5kT3V0cHV0LFxuICB0eXBlIFBhcmFtZXRlcixcbiAgdHlwZSBSZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJ5LFxuICB0eXBlIFJlc291cmNlVG9JbXBvcnQsXG4gIHR5cGUgU3RhY2ssXG4gIHR5cGUgVGFnLFxufSBmcm9tICdAYXdzLXNkay9jbGllbnQtY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgQXNzZXRNYW5pZmVzdCwgRmlsZU1hbmlmZXN0RW50cnkgfSBmcm9tICdjZGstYXNzZXRzJztcbmltcG9ydCB7IEFzc2V0TWFuaWZlc3RCdWlsZGVyIH0gZnJvbSAnLi9hc3NldC1tYW5pZmVzdC1idWlsZGVyJztcbmltcG9ydCB0eXBlIHsgRGVwbG95bWVudHMgfSBmcm9tICcuL2RlcGxveW1lbnRzJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vY2xpL21lc3NhZ2VzJztcbmltcG9ydCB7IElvTWVzc2FnaW5nIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9jbGktaW8taG9zdCc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L2Vycm9yJztcbmltcG9ydCB7IGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL3V0aWwvZm9ybWF0LWVycm9yJztcbmltcG9ydCB7IGRlc2VyaWFsaXplU3RydWN0dXJlIH0gZnJvbSAnLi4vLi4vdXRpbC9zZXJpYWxpemUnO1xuaW1wb3J0IHR5cGUgeyBJQ2xvdWRGb3JtYXRpb25DbGllbnQsIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgU3RhY2tTdGF0dXMgfSBmcm9tICcuLi9zdGFjay1ldmVudHMnO1xuaW1wb3J0IHsgbWFrZUJvZHlQYXJhbWV0ZXIsIFRlbXBsYXRlQm9keVBhcmFtZXRlciB9IGZyb20gJy4uL3V0aWwvdGVtcGxhdGUtYm9keS1wYXJhbWV0ZXInO1xuXG5leHBvcnQgdHlwZSBSZXNvdXJjZXNUb0ltcG9ydCA9IFJlc291cmNlVG9JbXBvcnRbXTtcbmV4cG9ydCB0eXBlIFJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyA9IFJlc291cmNlSWRlbnRpZmllclN1bW1hcnlbXTtcbmV4cG9ydCB0eXBlIFJlc291cmNlSWRlbnRpZmllclByb3BlcnRpZXMgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG5leHBvcnQgdHlwZSBUZW1wbGF0ZSA9IHtcbiAgUGFyYW1ldGVycz86IFJlY29yZDxzdHJpbmcsIFRlbXBsYXRlUGFyYW1ldGVyPjtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufTtcblxuaW50ZXJmYWNlIFRlbXBsYXRlUGFyYW1ldGVyIHtcbiAgVHlwZTogc3RyaW5nO1xuICBEZWZhdWx0PzogYW55O1xuICBEZXNjcmlwdGlvbj86IHN0cmluZztcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gKGV4aXN0aW5nKSBTdGFjayBpbiBDbG91ZEZvcm1hdGlvblxuICpcbiAqIEJ1bmRsZSBhbmQgY2FjaGUgc29tZSBpbmZvcm1hdGlvbiB0aGF0IHdlIG5lZWQgZHVyaW5nIGRlcGxveW1lbnQgKHNvIHdlIGRvbid0IGhhdmUgdG8gbWFrZVxuICogcmVwZWF0ZWQgY2FsbHMgdG8gQ2xvdWRGb3JtYXRpb24pLlxuICovXG5leHBvcnQgY2xhc3MgQ2xvdWRGb3JtYXRpb25TdGFjayB7XG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9va3VwKFxuICAgIGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICAgIHN0YWNrTmFtZTogc3RyaW5nLFxuICAgIHJldHJpZXZlUHJvY2Vzc2VkVGVtcGxhdGU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvblN0YWNrPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2ZuLmRlc2NyaWJlU3RhY2tzKHsgU3RhY2tOYW1lOiBzdGFja05hbWUgfSk7XG4gICAgICByZXR1cm4gbmV3IENsb3VkRm9ybWF0aW9uU3RhY2soY2ZuLCBzdGFja05hbWUsIHJlc3BvbnNlLlN0YWNrcyAmJiByZXNwb25zZS5TdGFja3NbMF0sIHJldHJpZXZlUHJvY2Vzc2VkVGVtcGxhdGUpO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgaWYgKGUubmFtZSA9PT0gJ1ZhbGlkYXRpb25FcnJvcicgJiYgZm9ybWF0RXJyb3JNZXNzYWdlKGUpID09PSBgU3RhY2sgd2l0aCBpZCAke3N0YWNrTmFtZX0gZG9lcyBub3QgZXhpc3RgKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xvdWRGb3JtYXRpb25TdGFjayhjZm4sIHN0YWNrTmFtZSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvcHkgb2YgdGhlIGdpdmVuIHN0YWNrIHRoYXQgZG9lcyBub3QgZXhpc3RcbiAgICpcbiAgICogSXQncyBhIGxpdHRsZSBzaWxseSB0aGF0IGl0IG5lZWRzIGFyZ3VtZW50cyB0byBkbyB0aGF0LCBidXQgdGhlcmUgd2UgZ28uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGRvZXNOb3RFeGlzdChjZm46IElDbG91ZEZvcm1hdGlvbkNsaWVudCwgc3RhY2tOYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IENsb3VkRm9ybWF0aW9uU3RhY2soY2ZuLCBzdGFja05hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyb20gc3RhdGljIGluZm9ybWF0aW9uIChmb3IgdGVzdGluZylcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVN0YXRpY0luZm9ybWF0aW9uKGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50LCBzdGFja05hbWU6IHN0cmluZywgc3RhY2s6IFN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCBzdGFjayk7XG4gIH1cblxuICBwcml2YXRlIF90ZW1wbGF0ZTogYW55O1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICAgIHB1YmxpYyByZWFkb25seSBzdGFja05hbWU6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrPzogU3RhY2ssXG4gICAgcHJpdmF0ZSByZWFkb25seSByZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlOiBib29sZWFuID0gZmFsc2UsXG4gICkge1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBzdGFjaydzIGRlcGxveWVkIHRlbXBsYXRlXG4gICAqXG4gICAqIENhY2hlZCwgc28gd2lsbCBvbmx5IGJlIHJldHJpZXZlZCBvbmNlLiBXaWxsIHJldHVybiBhbiBlbXB0eVxuICAgKiBzdHJ1Y3R1cmUgaWYgdGhlIHN0YWNrIGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHRlbXBsYXRlKCk6IFByb21pc2U8VGVtcGxhdGU+IHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jZm4uZ2V0VGVtcGxhdGUoe1xuICAgICAgICBTdGFja05hbWU6IHRoaXMuc3RhY2tOYW1lLFxuICAgICAgICBUZW1wbGF0ZVN0YWdlOiB0aGlzLnJldHJpZXZlUHJvY2Vzc2VkVGVtcGxhdGUgPyAnUHJvY2Vzc2VkJyA6ICdPcmlnaW5hbCcsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gKHJlc3BvbnNlLlRlbXBsYXRlQm9keSAmJiBkZXNlcmlhbGl6ZVN0cnVjdHVyZShyZXNwb25zZS5UZW1wbGF0ZUJvZHkpKSB8fCB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHN0YWNrIGV4aXN0c1xuICAgKi9cbiAgcHVibGljIGdldCBleGlzdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2sgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBJRFxuICAgKlxuICAgKiBUaHJvd3MgaWYgdGhlIHN0YWNrIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YWNrSWQoKSB7XG4gICAgdGhpcy5hc3NlcnRFeGlzdHMoKTtcbiAgICByZXR1cm4gdGhpcy5zdGFjayEuU3RhY2tJZCE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YWNrJ3MgY3VycmVudCBvdXRwdXRzXG4gICAqXG4gICAqIEVtcHR5IG9iamVjdCBpZiB0aGUgc3RhY2sgZG9lc24ndCBleGlzdFxuICAgKi9cbiAgcHVibGljIGdldCBvdXRwdXRzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5leGlzdHMpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0OiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICAgICh0aGlzLnN0YWNrIS5PdXRwdXRzIHx8IFtdKS5mb3JFYWNoKChvdXRwdXQpID0+IHtcbiAgICAgIHJlc3VsdFtvdXRwdXQuT3V0cHV0S2V5IV0gPSBvdXRwdXQuT3V0cHV0VmFsdWUhO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YWNrJ3Mgc3RhdHVzXG4gICAqXG4gICAqIFNwZWNpYWwgc3RhdHVzIE5PVF9GT1VORCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YWNrU3RhdHVzKCk6IFN0YWNrU3RhdHVzIHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7XG4gICAgICByZXR1cm4gbmV3IFN0YWNrU3RhdHVzKCdOT1RfRk9VTkQnLCAnU3RhY2sgbm90IGZvdW5kIGR1cmluZyBsb29rdXAnKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrU3RhdHVzLmZyb21TdGFja0Rlc2NyaXB0aW9uKHRoaXMuc3RhY2shKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBjdXJyZW50IHRhZ3NcbiAgICpcbiAgICogRW1wdHkgbGlzdCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3RcbiAgICovXG4gIHB1YmxpYyBnZXQgdGFncygpOiBUYWdbXSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2s/LlRhZ3MgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogU05TIFRvcGljIEFSTnMgdGhhdCB3aWxsIHJlY2VpdmUgc3RhY2sgZXZlbnRzLlxuICAgKlxuICAgKiBFbXB0eSBsaXN0IGlmIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdFxuICAgKi9cbiAgcHVibGljIGdldCBub3RpZmljYXRpb25Bcm5zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjaz8uTm90aWZpY2F0aW9uQVJOcyA/PyBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5hbWVzIG9mIGFsbCBjdXJyZW50IHBhcmFtZXRlcnMgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEVtcHR5IGxpc3QgaWYgdGhlIHN0YWNrIGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgcHVibGljIGdldCBwYXJhbWV0ZXJOYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucGFyYW1ldGVycyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGFsbCBjdXJyZW50IHBhcmFtZXRlcnMgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEVtcHR5IG9iamVjdCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBhcmFtZXRlcnMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCByZXQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHRoaXMuc3RhY2shLlBhcmFtZXRlcnMgPz8gW10pIHtcbiAgICAgIHJldFtwYXJhbS5QYXJhbWV0ZXJLZXkhXSA9IHBhcmFtLlJlc29sdmVkVmFsdWUgPz8gcGFyYW0uUGFyYW1ldGVyVmFsdWUhO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGVybWluYXRpb24gcHJvdGVjdGlvbiBvZiB0aGUgc3RhY2tcbiAgICovXG4gIHB1YmxpYyBnZXQgdGVybWluYXRpb25Qcm90ZWN0aW9uKCk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN0YWNrPy5FbmFibGVUZXJtaW5hdGlvblByb3RlY3Rpb247XG4gIH1cblxuICBwcml2YXRlIGFzc2VydEV4aXN0cygpIHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBObyBzdGFjayBuYW1lZCAnJHt0aGlzLnN0YWNrTmFtZX0nYCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGVzY3JpYmUgYSBjaGFuZ2VzZXQgaW4gQ2xvdWRGb3JtYXRpb24sIHJlZ2FyZGxlc3Mgb2YgaXRzIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgIHRoZSBuYW1lIG9mIHRoZSBTdGFjayB0aGUgQ2hhbmdlU2V0IGJlbG9uZ3MgdG9cbiAqIEBwYXJhbSBjaGFuZ2VTZXROYW1lIHRoZSBuYW1lIG9mIHRoZSBDaGFuZ2VTZXRcbiAqIEBwYXJhbSBmZXRjaEFsbCAgICAgIGlmIHRydWUsIGZldGNoZXMgYWxsIHBhZ2VzIG9mIHRoZSBjaGFuZ2Ugc2V0IGRlc2NyaXB0aW9uLlxuICpcbiAqIEByZXR1cm5zICAgICAgIENsb3VkRm9ybWF0aW9uIGluZm9ybWF0aW9uIGFib3V0IHRoZSBDaGFuZ2VTZXRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVzY3JpYmVDaGFuZ2VTZXQoXG4gIGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICBzdGFja05hbWU6IHN0cmluZyxcbiAgY2hhbmdlU2V0TmFtZTogc3RyaW5nLFxuICB7IGZldGNoQWxsIH06IHsgZmV0Y2hBbGw6IGJvb2xlYW4gfSxcbik6IFByb21pc2U8RGVzY3JpYmVDaGFuZ2VTZXRDb21tYW5kT3V0cHV0PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2ZuLmRlc2NyaWJlQ2hhbmdlU2V0KHtcbiAgICBTdGFja05hbWU6IHN0YWNrTmFtZSxcbiAgICBDaGFuZ2VTZXROYW1lOiBjaGFuZ2VTZXROYW1lLFxuICB9KTtcblxuICAvLyBJZiBmZXRjaEFsbCBpcyB0cnVlLCB0cmF2ZXJzZSBhbGwgcGFnZXMgZnJvbSB0aGUgY2hhbmdlIHNldCBkZXNjcmlwdGlvbi5cbiAgd2hpbGUgKGZldGNoQWxsICYmIHJlc3BvbnNlLk5leHRUb2tlbiAhPSBudWxsKSB7XG4gICAgY29uc3QgbmV4dFBhZ2UgPSBhd2FpdCBjZm4uZGVzY3JpYmVDaGFuZ2VTZXQoe1xuICAgICAgU3RhY2tOYW1lOiBzdGFja05hbWUsXG4gICAgICBDaGFuZ2VTZXROYW1lOiByZXNwb25zZS5DaGFuZ2VTZXRJZCA/PyBjaGFuZ2VTZXROYW1lLFxuICAgICAgTmV4dFRva2VuOiByZXNwb25zZS5OZXh0VG9rZW4sXG4gICAgfSk7XG5cbiAgICAvLyBDb25zb2xpZGF0ZSB0aGUgY2hhbmdlc1xuICAgIGlmIChuZXh0UGFnZS5DaGFuZ2VzICE9IG51bGwpIHtcbiAgICAgIHJlc3BvbnNlLkNoYW5nZXMgPSByZXNwb25zZS5DaGFuZ2VzICE9IG51bGwgPyByZXNwb25zZS5DaGFuZ2VzLmNvbmNhdChuZXh0UGFnZS5DaGFuZ2VzKSA6IG5leHRQYWdlLkNoYW5nZXM7XG4gICAgfVxuXG4gICAgLy8gRm9yd2FyZCB0aGUgbmV3IE5leHRUb2tlblxuICAgIHJlc3BvbnNlLk5leHRUb2tlbiA9IG5leHRQYWdlLk5leHRUb2tlbjtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuLyoqXG4gKiBXYWl0cyBmb3IgYSBmdW5jdGlvbiB0byByZXR1cm4gbm9uLSt1bmRlZmluZWQrIGJlZm9yZSByZXR1cm5pbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlUHJvdmlkZXIgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIGEgdmFsdWUgdGhhdCBpcyBub3QgK3VuZGVmaW5lZCsgb25jZSB0aGUgd2FpdCBzaG91bGQgYmUgb3ZlclxuICogQHBhcmFtIHRpbWVvdXQgICAgIHRoZSB0aW1lIHRvIHdhaXQgYmV0d2VlbiB0d28gY2FsbHMgdG8gK3ZhbHVlUHJvdmlkZXIrXG4gKlxuICogQHJldHVybnMgICAgICAgdGhlIHZhbHVlIHRoYXQgd2FzIHJldHVybmVkIGJ5ICt2YWx1ZVByb3ZpZGVyK1xuICovXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yPFQ+KFxuICB2YWx1ZVByb3ZpZGVyOiAoKSA9PiBQcm9taXNlPFQgfCBudWxsIHwgdW5kZWZpbmVkPixcbiAgdGltZW91dDogbnVtYmVyID0gNTAwMCxcbik6IFByb21pc2U8VCB8IHVuZGVmaW5lZD4ge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbHVlUHJvdmlkZXIoKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChjYikgPT4gc2V0VGltZW91dChjYiwgdGltZW91dCkpO1xuICB9XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgQ2hhbmdlU2V0IHRvIGJlIGF2YWlsYWJsZSBmb3IgdHJpZ2dlcmluZyBhIFN0YWNrVXBkYXRlLlxuICpcbiAqIFdpbGwgcmV0dXJuIGEgY2hhbmdlc2V0IHRoYXQgaXMgZWl0aGVyIHJlYWR5IHRvIGJlIGV4ZWN1dGVkIG9yIGhhcyBubyBjaGFuZ2VzLlxuICogV2lsbCB0aHJvdyBpbiBvdGhlciBjYXNlcy5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICAgICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSAgICAgdGhlIG5hbWUgb2YgdGhlIFN0YWNrIHRoYXQgdGhlIENoYW5nZVNldCBiZWxvbmdzIHRvXG4gKiBAcGFyYW0gY2hhbmdlU2V0TmFtZSB0aGUgbmFtZSBvZiB0aGUgQ2hhbmdlU2V0XG4gKiBAcGFyYW0gZmV0Y2hBbGwgICAgICBpZiB0cnVlLCBmZXRjaGVzIGFsbCBwYWdlcyBvZiB0aGUgQ2hhbmdlU2V0IGJlZm9yZSByZXR1cm5pbmcuXG4gKlxuICogQHJldHVybnMgICAgICAgdGhlIENsb3VkRm9ybWF0aW9uIGRlc2NyaXB0aW9uIG9mIHRoZSBDaGFuZ2VTZXRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JDaGFuZ2VTZXQoXG4gIGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICB7IGlvSG9zdCwgYWN0aW9uIH06IElvTWVzc2FnaW5nLFxuICBzdGFja05hbWU6IHN0cmluZyxcbiAgY2hhbmdlU2V0TmFtZTogc3RyaW5nLFxuICB7IGZldGNoQWxsIH06IHsgZmV0Y2hBbGw6IGJvb2xlYW4gfSxcbik6IFByb21pc2U8RGVzY3JpYmVDaGFuZ2VTZXRDb21tYW5kT3V0cHV0PiB7XG4gIGF3YWl0IGlvSG9zdC5ub3RpZnkoZGVidWcoYWN0aW9uLCBmb3JtYXQoJ1dhaXRpbmcgZm9yIGNoYW5nZXNldCAlcyBvbiBzdGFjayAlcyB0byBmaW5pc2ggY3JlYXRpbmcuLi4nLCBjaGFuZ2VTZXROYW1lLCBzdGFja05hbWUpKSk7XG4gIGNvbnN0IHJldCA9IGF3YWl0IHdhaXRGb3IoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYXdhaXQgZGVzY3JpYmVDaGFuZ2VTZXQoY2ZuLCBzdGFja05hbWUsIGNoYW5nZVNldE5hbWUsIHtcbiAgICAgIGZldGNoQWxsLFxuICAgIH0pO1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgZG9lc24ndCB1c2UgYSBzd2l0Y2ggYmVjYXVzZSB0c2Mgd2lsbCBub3QgYWxsb3cgZmFsbC10aHJvdWdoLCBVTkxFU1MgaXQgaXMgYWxsb3dzXG4gICAgLy8gRVZFUllXSEVSRSB0aGF0IHVzZXMgdGhpcyBsaWJyYXJ5IGRpcmVjdGx5IG9yIGluZGlyZWN0bHksIHdoaWNoIGlzIHVuZGVzaXJhYmxlLlxuICAgIGlmIChkZXNjcmlwdGlvbi5TdGF0dXMgPT09ICdDUkVBVEVfUEVORElORycgfHwgZGVzY3JpcHRpb24uU3RhdHVzID09PSAnQ1JFQVRFX0lOX1BST0dSRVNTJykge1xuICAgICAgYXdhaXQgaW9Ib3N0Lm5vdGlmeShkZWJ1ZyhhY3Rpb24sIGZvcm1hdCgnQ2hhbmdlc2V0ICVzIG9uIHN0YWNrICVzIGlzIHN0aWxsIGNyZWF0aW5nJywgY2hhbmdlU2V0TmFtZSwgc3RhY2tOYW1lKSkpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZGVzY3JpcHRpb24uU3RhdHVzID09PSBDaGFuZ2VTZXRTdGF0dXMuQ1JFQVRFX0NPTVBMRVRFIHx8IGNoYW5nZVNldEhhc05vQ2hhbmdlcyhkZXNjcmlwdGlvbikpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICBgRmFpbGVkIHRvIGNyZWF0ZSBDaGFuZ2VTZXQgJHtjaGFuZ2VTZXROYW1lfSBvbiAke3N0YWNrTmFtZX06ICR7ZGVzY3JpcHRpb24uU3RhdHVzIHx8ICdOT19TVEFUVVMnfSwgJHtkZXNjcmlwdGlvbi5TdGF0dXNSZWFzb24gfHwgJ25vIHJlYXNvbiBwcm92aWRlZCd9YCxcbiAgICApO1xuICB9KTtcblxuICBpZiAoIXJldCkge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ0NoYW5nZSBzZXQgdG9vayB0b28gbG9uZyB0byBiZSBjcmVhdGVkOyBhYm9ydGluZycpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IHR5cGUgUHJlcGFyZUNoYW5nZVNldE9wdGlvbnMgPSB7XG4gIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG4gIGRlcGxveW1lbnRzOiBEZXBsb3ltZW50cztcbiAgdXVpZDogc3RyaW5nO1xuICB3aWxsRXhlY3V0ZTogYm9vbGVhbjtcbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyO1xuICBzdHJlYW06IE5vZGVKUy5Xcml0YWJsZVN0cmVhbTtcbiAgcGFyYW1ldGVyczogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG4gIHJlc291cmNlc1RvSW1wb3J0PzogUmVzb3VyY2VzVG9JbXBvcnQ7XG59XG5cbmV4cG9ydCB0eXBlIENyZWF0ZUNoYW5nZVNldE9wdGlvbnMgPSB7XG4gIGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50O1xuICBjaGFuZ2VTZXROYW1lOiBzdHJpbmc7XG4gIHdpbGxFeGVjdXRlOiBib29sZWFuO1xuICBleGlzdHM6IGJvb2xlYW47XG4gIHV1aWQ6IHN0cmluZztcbiAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcbiAgYm9keVBhcmFtZXRlcjogVGVtcGxhdGVCb2R5UGFyYW1ldGVyO1xuICBwYXJhbWV0ZXJzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfTtcbiAgcmVzb3VyY2VzVG9JbXBvcnQ/OiBSZXNvdXJjZVRvSW1wb3J0W107XG4gIHJvbGU/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGNoYW5nZXNldCBmb3IgYSBkaWZmIG9wZXJhdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGlmZkNoYW5nZVNldChcbiAgeyBpb0hvc3QsIGFjdGlvbiB9OiBJb01lc3NhZ2luZyxcbiAgb3B0aW9uczogUHJlcGFyZUNoYW5nZVNldE9wdGlvbnMsXG4pOiBQcm9taXNlPERlc2NyaWJlQ2hhbmdlU2V0Q29tbWFuZE91dHB1dCB8IHVuZGVmaW5lZD4ge1xuICAvLyBgb3B0aW9ucy5zdGFja2AgaGFzIGJlZW4gbW9kaWZpZWQgdG8gaW5jbHVkZSBhbnkgbmVzdGVkIHN0YWNrIHRlbXBsYXRlcyBkaXJlY3RseSBpbmxpbmUgd2l0aCBpdHMgb3duIHRlbXBsYXRlLCB1bmRlciBhIHNwZWNpYWwgYE5lc3RlZFRlbXBsYXRlYCBwcm9wZXJ0eS5cbiAgLy8gVGh1cyB0aGUgcGFyZW50IHRlbXBsYXRlJ3MgUmVzb3VyY2VzIHNlY3Rpb24gY29udGFpbnMgdGhlIG5lc3RlZCB0ZW1wbGF0ZSdzIENESyBtZXRhZGF0YSBjaGVjaywgd2hpY2ggdXNlcyBGbjo6RXF1YWxzLlxuICAvLyBUaGlzIGNhdXNlcyBDcmVhdGVDaGFuZ2VTZXQgdG8gZmFpbCB3aXRoIGBUZW1wbGF0ZSBFcnJvcjogRm46OkVxdWFscyBjYW5ub3QgYmUgcGFydGlhbGx5IGNvbGxhcHNlZGAuXG4gIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgT2JqZWN0LnZhbHVlcyhvcHRpb25zLnN0YWNrLnRlbXBsYXRlLlJlc291cmNlcyA/PyB7fSkpIHtcbiAgICBpZiAoKHJlc291cmNlIGFzIGFueSkuVHlwZSA9PT0gJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJykge1xuICAgICAgYXdhaXQgaW9Ib3N0Lm5vdGlmeShkZWJ1ZyhhY3Rpb24sICdUaGlzIHN0YWNrIGNvbnRhaW5zIG9uZSBvciBtb3JlIG5lc3RlZCBzdGFja3MsIGZhbGxpbmcgYmFjayB0byB0ZW1wbGF0ZS1vbmx5IGRpZmYuLi4nKSk7XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwbG9hZEJvZHlQYXJhbWV0ZXJBbmRDcmVhdGVDaGFuZ2VTZXQoeyBpb0hvc3QsIGFjdGlvbiB9LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBmaWxlIGVudHJpZXMgZnJvbSBhbiBBc3NldE1hbmlmZXN0QXJ0aWZhY3QgdGhhdCBsb29rIGxpa2UgdGVtcGxhdGVzLlxuICpcbiAqIFRoaXMgaXMgdXNlZCBpbiB0aGUgYHVwbG9hZEJvZHlQYXJhbWV0ZXJBbmRDcmVhdGVDaGFuZ2VTZXRgIGZ1bmN0aW9uIHRvIGZpbmRcbiAqIGFsbCB0ZW1wbGF0ZSBhc3NldCBmaWxlcyB0byBidWlsZCBhbmQgcHVibGlzaC5cbiAqXG4gKiBSZXR1cm5zIGEgdHVwbGUgb2YgW0Fzc2V0TWFuaWZlc3QsIEZpbGVNYW5pZmVzdEVudHJ5W11dXG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlc0Zyb21Bc3NldE1hbmlmZXN0QXJ0aWZhY3QoXG4gIGFydGlmYWN0OiBjeGFwaS5Bc3NldE1hbmlmZXN0QXJ0aWZhY3QsXG4pOiBbQXNzZXRNYW5pZmVzdCwgRmlsZU1hbmlmZXN0RW50cnlbXV0ge1xuICBjb25zdCBhc3NldHM6IEZpbGVNYW5pZmVzdEVudHJ5W10gPSBbXTtcbiAgY29uc3QgZmlsZU5hbWUgPSBhcnRpZmFjdC5maWxlO1xuICBjb25zdCBhc3NldE1hbmlmZXN0ID0gQXNzZXRNYW5pZmVzdC5mcm9tRmlsZShmaWxlTmFtZSk7XG5cbiAgYXNzZXRNYW5pZmVzdC5lbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgaWYgKGVudHJ5LnR5cGUgPT09ICdmaWxlJykge1xuICAgICAgY29uc3Qgc291cmNlID0gKGVudHJ5IGFzIEZpbGVNYW5pZmVzdEVudHJ5KS5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlLnBhdGggJiYgc291cmNlLnBhdGguZW5kc1dpdGgoJy50ZW1wbGF0ZS5qc29uJykpIHtcbiAgICAgICAgYXNzZXRzLnB1c2goZW50cnkgYXMgRmlsZU1hbmlmZXN0RW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBbYXNzZXRNYW5pZmVzdCwgYXNzZXRzXTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkQm9keVBhcmFtZXRlckFuZENyZWF0ZUNoYW5nZVNldChcbiAgeyBpb0hvc3QsIGFjdGlvbiB9OiBJb01lc3NhZ2luZyxcbiAgb3B0aW9uczogUHJlcGFyZUNoYW5nZVNldE9wdGlvbnMsXG4pOiBQcm9taXNlPERlc2NyaWJlQ2hhbmdlU2V0Q29tbWFuZE91dHB1dCB8IHVuZGVmaW5lZD4ge1xuICB0cnkge1xuICAgIGF3YWl0IHVwbG9hZFN0YWNrVGVtcGxhdGVBc3NldHMob3B0aW9ucy5zdGFjaywgb3B0aW9ucy5kZXBsb3ltZW50cyk7XG4gICAgY29uc3QgZW52ID0gYXdhaXQgb3B0aW9ucy5kZXBsb3ltZW50cy5lbnZzLmFjY2Vzc1N0YWNrRm9yTXV0YWJsZVN0YWNrT3BlcmF0aW9ucyhvcHRpb25zLnN0YWNrKTtcblxuICAgIGNvbnN0IGJvZHlQYXJhbWV0ZXIgPSBhd2FpdCBtYWtlQm9keVBhcmFtZXRlcihcbiAgICAgIG9wdGlvbnMuc3RhY2ssXG4gICAgICBlbnYucmVzb2x2ZWRFbnZpcm9ubWVudCxcbiAgICAgIG5ldyBBc3NldE1hbmlmZXN0QnVpbGRlcigpLFxuICAgICAgZW52LnJlc291cmNlcyxcbiAgICApO1xuICAgIGNvbnN0IGNmbiA9IGVudi5zZGsuY2xvdWRGb3JtYXRpb24oKTtcbiAgICBjb25zdCBleGlzdHMgPSAoYXdhaXQgQ2xvdWRGb3JtYXRpb25TdGFjay5sb29rdXAoY2ZuLCBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSwgZmFsc2UpKS5leGlzdHM7XG5cbiAgICBjb25zdCBleGVjdXRpb25Sb2xlQXJuID0gYXdhaXQgZW52LnJlcGxhY2VQbGFjZWhvbGRlcnMob3B0aW9ucy5zdGFjay5jbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblJvbGVBcm4pO1xuICAgIG9wdGlvbnMuc3RyZWFtLndyaXRlKFxuICAgICAgJ0hvbGQgb24gd2hpbGUgd2UgY3JlYXRlIGEgcmVhZC1vbmx5IGNoYW5nZSBzZXQgdG8gZ2V0IGEgZGlmZiB3aXRoIGFjY3VyYXRlIHJlcGxhY2VtZW50IGluZm9ybWF0aW9uICh1c2UgLS1uby1jaGFuZ2Utc2V0IHRvIHVzZSBhIGxlc3MgYWNjdXJhdGUgYnV0IGZhc3RlciB0ZW1wbGF0ZS1vbmx5IGRpZmYpXFxuJyxcbiAgICApO1xuXG4gICAgcmV0dXJuIGF3YWl0IGNyZWF0ZUNoYW5nZVNldCh7IGlvSG9zdCwgYWN0aW9uIH0sIHtcbiAgICAgIGNmbixcbiAgICAgIGNoYW5nZVNldE5hbWU6ICdjZGstZGlmZi1jaGFuZ2Utc2V0JyxcbiAgICAgIHN0YWNrOiBvcHRpb25zLnN0YWNrLFxuICAgICAgZXhpc3RzLFxuICAgICAgdXVpZDogb3B0aW9ucy51dWlkLFxuICAgICAgd2lsbEV4ZWN1dGU6IG9wdGlvbnMud2lsbEV4ZWN1dGUsXG4gICAgICBib2R5UGFyYW1ldGVyLFxuICAgICAgcGFyYW1ldGVyczogb3B0aW9ucy5wYXJhbWV0ZXJzLFxuICAgICAgcmVzb3VyY2VzVG9JbXBvcnQ6IG9wdGlvbnMucmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgICByb2xlOiBleGVjdXRpb25Sb2xlQXJuLFxuICAgIH0pO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICBhd2FpdCBpb0hvc3Qubm90aWZ5KGRlYnVnKGFjdGlvbiwgZSkpO1xuICAgIG9wdGlvbnMuc3RyZWFtLndyaXRlKFxuICAgICAgJ0NvdWxkIG5vdCBjcmVhdGUgYSBjaGFuZ2Ugc2V0LCB3aWxsIGJhc2UgdGhlIGRpZmYgb24gdGVtcGxhdGUgZGlmZmVyZW5jZXMgKHJ1biBhZ2FpbiB3aXRoIC12IHRvIHNlZSB0aGUgcmVhc29uKVxcbicsXG4gICAgKTtcblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBVcGxvYWRzIHRoZSBhc3NldHMgdGhhdCBsb29rIGxpa2UgdGVtcGxhdGVzIGZvciB0aGlzIENsb3VkRm9ybWF0aW9uIHN0YWNrXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgZm9yIGFueSBDbG91ZEZvcm1hdGlvbiBjYWxsIHRoYXQgbmVlZHMgdGhlIHRlbXBsYXRlLCBpdCBtYXkgbmVlZFxuICogdG8gYmUgdXBsb2FkZWQgdG8gYW4gUzMgYnVja2V0IGZpcnN0LiBXZSBoYXZlIHRvIGZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGluIHRoZVxuICogYXNzZXQgbWFuaWZlc3QsIGJlY2F1c2UgdGVjaG5pY2FsbHkgdGhhdCBpcyB0aGUgb25seSBwbGFjZSB0aGF0IGtub3dzIGFib3V0XG4gKiBidWNrZXQgYW5kIGFzc3VtZWQgcm9sZXMgYW5kIHN1Y2guXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWRTdGFja1RlbXBsYXRlQXNzZXRzKHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsIGRlcGxveW1lbnRzOiBEZXBsb3ltZW50cykge1xuICBmb3IgKGNvbnN0IGFydGlmYWN0IG9mIHN0YWNrLmRlcGVuZGVuY2llcykge1xuICAgIC8vIFNraXAgYXJ0aWZhY3QgaWYgaXQgaXMgbm90IGFuIEFzc2V0IE1hbmlmZXN0IEFydGlmYWN0XG4gICAgaWYgKCFjeGFwaS5Bc3NldE1hbmlmZXN0QXJ0aWZhY3QuaXNBc3NldE1hbmlmZXN0QXJ0aWZhY3QoYXJ0aWZhY3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBbYXNzZXRNYW5pZmVzdCwgZmlsZV9lbnRyaWVzXSA9IHRlbXBsYXRlc0Zyb21Bc3NldE1hbmlmZXN0QXJ0aWZhY3QoYXJ0aWZhY3QpO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZmlsZV9lbnRyaWVzKSB7XG4gICAgICBhd2FpdCBkZXBsb3ltZW50cy5idWlsZFNpbmdsZUFzc2V0KGFydGlmYWN0LCBhc3NldE1hbmlmZXN0LCBlbnRyeSwge1xuICAgICAgICBzdGFjayxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgZGVwbG95bWVudHMucHVibGlzaFNpbmdsZUFzc2V0KGFzc2V0TWFuaWZlc3QsIGVudHJ5LCB7XG4gICAgICAgIHN0YWNrLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDaGFuZ2VTZXQoXG4gIHsgaW9Ib3N0LCBhY3Rpb24gfTogSW9NZXNzYWdpbmcsXG4gIG9wdGlvbnM6IENyZWF0ZUNoYW5nZVNldE9wdGlvbnMsXG4pOiBQcm9taXNlPERlc2NyaWJlQ2hhbmdlU2V0Q29tbWFuZE91dHB1dD4ge1xuICBhd2FpdCBjbGVhbnVwT2xkQ2hhbmdlc2V0KG9wdGlvbnMuY2ZuLCB7IGlvSG9zdCwgYWN0aW9uIH0sIG9wdGlvbnMuY2hhbmdlU2V0TmFtZSwgb3B0aW9ucy5zdGFjay5zdGFja05hbWUpO1xuXG4gIGF3YWl0IGlvSG9zdC5ub3RpZnkoZGVidWcoYWN0aW9uLCBgQXR0ZW1wdGluZyB0byBjcmVhdGUgQ2hhbmdlU2V0IHdpdGggbmFtZSAke29wdGlvbnMuY2hhbmdlU2V0TmFtZX0gZm9yIHN0YWNrICR7b3B0aW9ucy5zdGFjay5zdGFja05hbWV9YCkpO1xuXG4gIGNvbnN0IHRlbXBsYXRlUGFyYW1zID0gVGVtcGxhdGVQYXJhbWV0ZXJzLmZyb21UZW1wbGF0ZShvcHRpb25zLnN0YWNrLnRlbXBsYXRlKTtcbiAgY29uc3Qgc3RhY2tQYXJhbXMgPSB0ZW1wbGF0ZVBhcmFtcy5zdXBwbHlBbGwob3B0aW9ucy5wYXJhbWV0ZXJzKTtcblxuICBjb25zdCBjaGFuZ2VTZXQgPSBhd2FpdCBvcHRpb25zLmNmbi5jcmVhdGVDaGFuZ2VTZXQoe1xuICAgIFN0YWNrTmFtZTogb3B0aW9ucy5zdGFjay5zdGFja05hbWUsXG4gICAgQ2hhbmdlU2V0TmFtZTogb3B0aW9ucy5jaGFuZ2VTZXROYW1lLFxuICAgIENoYW5nZVNldFR5cGU6IG9wdGlvbnMucmVzb3VyY2VzVG9JbXBvcnQgPyAnSU1QT1JUJyA6IG9wdGlvbnMuZXhpc3RzID8gJ1VQREFURScgOiAnQ1JFQVRFJyxcbiAgICBEZXNjcmlwdGlvbjogYENESyBDaGFuZ2VzZXQgZm9yIGRpZmYgJHtvcHRpb25zLnV1aWR9YCxcbiAgICBDbGllbnRUb2tlbjogYGRpZmYke29wdGlvbnMudXVpZH1gLFxuICAgIFRlbXBsYXRlVVJMOiBvcHRpb25zLmJvZHlQYXJhbWV0ZXIuVGVtcGxhdGVVUkwsXG4gICAgVGVtcGxhdGVCb2R5OiBvcHRpb25zLmJvZHlQYXJhbWV0ZXIuVGVtcGxhdGVCb2R5LFxuICAgIFBhcmFtZXRlcnM6IHN0YWNrUGFyYW1zLmFwaVBhcmFtZXRlcnMsXG4gICAgUmVzb3VyY2VzVG9JbXBvcnQ6IG9wdGlvbnMucmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgUm9sZUFSTjogb3B0aW9ucy5yb2xlLFxuICAgIFRhZ3M6IHRvQ2ZuVGFncyhvcHRpb25zLnN0YWNrLnRhZ3MpLFxuICAgIENhcGFiaWxpdGllczogWydDQVBBQklMSVRZX0lBTScsICdDQVBBQklMSVRZX05BTUVEX0lBTScsICdDQVBBQklMSVRZX0FVVE9fRVhQQU5EJ10sXG4gIH0pO1xuXG4gIGF3YWl0IGlvSG9zdC5ub3RpZnkoZGVidWcoYWN0aW9uLCBmb3JtYXQoJ0luaXRpYXRlZCBjcmVhdGlvbiBvZiBjaGFuZ2VzZXQ6ICVzOyB3YWl0aW5nIGZvciBpdCB0byBmaW5pc2ggY3JlYXRpbmcuLi4nLCBjaGFuZ2VTZXQuSWQpKSk7XG4gIC8vIEZldGNoaW5nIGFsbCBwYWdlcyBpZiB3ZSdsbCBleGVjdXRlLCBzbyB3ZSBjYW4gaGF2ZSB0aGUgY29ycmVjdCBjaGFuZ2UgY291bnQgd2hlbiBtb25pdG9yaW5nLlxuICBjb25zdCBjcmVhdGVkQ2hhbmdlU2V0ID0gYXdhaXQgd2FpdEZvckNoYW5nZVNldChvcHRpb25zLmNmbiwgeyBpb0hvc3QsIGFjdGlvbiB9LCBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSwgb3B0aW9ucy5jaGFuZ2VTZXROYW1lLCB7XG4gICAgZmV0Y2hBbGw6IG9wdGlvbnMud2lsbEV4ZWN1dGUsXG4gIH0pO1xuICBhd2FpdCBjbGVhbnVwT2xkQ2hhbmdlc2V0KG9wdGlvbnMuY2ZuLCB7IGlvSG9zdCwgYWN0aW9uIH0sIG9wdGlvbnMuY2hhbmdlU2V0TmFtZSwgb3B0aW9ucy5zdGFjay5zdGFja05hbWUpO1xuXG4gIHJldHVybiBjcmVhdGVkQ2hhbmdlU2V0O1xufVxuXG5mdW5jdGlvbiB0b0NmblRhZ3ModGFnczogeyBbaWQ6IHN0cmluZ106IHN0cmluZyB9KTogVGFnW10ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXModGFncykubWFwKChbaywgdl0pID0+ICh7XG4gICAgS2V5OiBrLFxuICAgIFZhbHVlOiB2LFxuICB9KSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNsZWFudXBPbGRDaGFuZ2VzZXQoXG4gIGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICB7IGlvSG9zdCwgYWN0aW9uIH06IElvTWVzc2FnaW5nLFxuICBjaGFuZ2VTZXROYW1lOiBzdHJpbmcsXG4gIHN0YWNrTmFtZTogc3RyaW5nLFxuKSB7XG4gIC8vIERlbGV0ZSBhbnkgZXhpc3RpbmcgY2hhbmdlIHNldHMgZ2VuZXJhdGVkIGJ5IENESyBzaW5jZSBjaGFuZ2Ugc2V0IG5hbWVzIG11c3QgYmUgdW5pcXVlLlxuICAvLyBUaGUgZGVsZXRlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCBhcyBsb25nIGFzIHRoZSBzdGFjayBleGlzdHMgKGV2ZW4gaWYgdGhlIGNoYW5nZSBzZXQgZG9lcyBub3QgZXhpc3QpLlxuICBhd2FpdCBpb0hvc3Qubm90aWZ5KGRlYnVnKGFjdGlvbiwgYFJlbW92aW5nIGV4aXN0aW5nIGNoYW5nZSBzZXQgd2l0aCBuYW1lICR7Y2hhbmdlU2V0TmFtZX0gaWYgaXQgZXhpc3RzYCkpO1xuICBhd2FpdCBjZm4uZGVsZXRlQ2hhbmdlU2V0KHtcbiAgICBTdGFja05hbWU6IHN0YWNrTmFtZSxcbiAgICBDaGFuZ2VTZXROYW1lOiBjaGFuZ2VTZXROYW1lLFxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gY2hhbmdlIHNldCBoYXMgbm8gY2hhbmdlc1xuICpcbiAqIFRoaXMgbXVzdCBiZSBkZXRlcm1pbmVkIGZyb20gdGhlIHN0YXR1cywgbm90IHRoZSAnQ2hhbmdlcycgYXJyYXkgb24gdGhlXG4gKiBvYmplY3Q7IHRoZSBsYXR0ZXIgY2FuIGJlIGVtcHR5IGJlY2F1c2Ugbm8gcmVzb3VyY2VzIHdlcmUgY2hhbmdlZCwgYnV0IGlmXG4gKiB0aGVyZSBhcmUgY2hhbmdlcyB0byBPdXRwdXRzLCB0aGUgY2hhbmdlIHNldCBjYW4gc3RpbGwgYmUgZXhlY3V0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VTZXRIYXNOb0NoYW5nZXMoZGVzY3JpcHRpb246IERlc2NyaWJlQ2hhbmdlU2V0Q29tbWFuZE91dHB1dCkge1xuICBjb25zdCBub0NoYW5nZUVycm9yUHJlZml4ZXMgPSBbXG4gICAgLy8gRXJyb3IgbWVzc2FnZSBmb3IgYSByZWd1bGFyIHRlbXBsYXRlXG4gICAgXCJUaGUgc3VibWl0dGVkIGluZm9ybWF0aW9uIGRpZG4ndCBjb250YWluIGNoYW5nZXMuXCIsXG4gICAgLy8gRXJyb3IgbWVzc2FnZSB3aGVuIGEgVHJhbnNmb3JtIGlzIGludm9sdmVkIChzZWUgIzEwNjUwKVxuICAgICdObyB1cGRhdGVzIGFyZSB0byBiZSBwZXJmb3JtZWQuJyxcbiAgXTtcblxuICByZXR1cm4gKFxuICAgIGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0ZBSUxFRCcgJiYgbm9DaGFuZ2VFcnJvclByZWZpeGVzLnNvbWUoKHApID0+IChkZXNjcmlwdGlvbi5TdGF0dXNSZWFzb24gPz8gJycpLnN0YXJ0c1dpdGgocCkpXG4gICk7XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgQ2xvdWRGb3JtYXRpb24gc3RhY2sgdG8gc3RhYmlsaXplIGluIGEgY29tcGxldGUvYXZhaWxhYmxlIHN0YXRlXG4gKiBhZnRlciBhIGRlbGV0ZSBvcGVyYXRpb24gaXMgaXNzdWVkLlxuICpcbiAqIEZhaWxzIGlmIHRoZSBzdGFjayBpcyBpbiBhIEZBSUxFRCBzdGF0ZS4gV2lsbCBub3QgZmFpbCBpZiB0aGUgc3RhY2sgd2FzXG4gKiBhbHJlYWR5IGRlbGV0ZWQuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgICB0aGUgbmFtZSBvZiB0aGUgc3RhY2sgdG8gd2FpdCBmb3IgYWZ0ZXIgYSBkZWxldGVcbiAqXG4gKiBAcmV0dXJucyAgICAgdGhlIENsb3VkRm9ybWF0aW9uIGRlc2NyaXB0aW9uIG9mIHRoZSBzdGFiaWxpemVkIHN0YWNrIGFmdGVyIHRoZSBkZWxldGUgYXR0ZW1wdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvclN0YWNrRGVsZXRlKFxuICBjZm46IElDbG91ZEZvcm1hdGlvbkNsaWVudCxcbiAgeyBpb0hvc3QsIGFjdGlvbiB9OiBJb01lc3NhZ2luZyxcbiAgc3RhY2tOYW1lOiBzdHJpbmcsXG4pOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uU3RhY2sgfCB1bmRlZmluZWQ+IHtcbiAgY29uc3Qgc3RhY2sgPSBhd2FpdCBzdGFiaWxpemVTdGFjayhjZm4sIHsgaW9Ib3N0LCBhY3Rpb24gfSwgc3RhY2tOYW1lKTtcbiAgaWYgKCFzdGFjaykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBzdGF0dXMgPSBzdGFjay5zdGFja1N0YXR1cztcbiAgaWYgKHN0YXR1cy5pc0ZhaWx1cmUpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgYFRoZSBzdGFjayBuYW1lZCAke3N0YWNrTmFtZX0gaXMgaW4gYSBmYWlsZWQgc3RhdGUuIFlvdSBtYXkgbmVlZCB0byBkZWxldGUgaXQgZnJvbSB0aGUgQVdTIGNvbnNvbGUgOiAke3N0YXR1c31gLFxuICAgICk7XG4gIH0gZWxzZSBpZiAoc3RhdHVzLmlzRGVsZXRlZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrO1xufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIENsb3VkRm9ybWF0aW9uIHN0YWNrIHRvIHN0YWJpbGl6ZSBpbiBhIGNvbXBsZXRlL2F2YWlsYWJsZSBzdGF0ZVxuICogYWZ0ZXIgYW4gdXBkYXRlL2NyZWF0ZSBvcGVyYXRpb24gaXMgaXNzdWVkLlxuICpcbiAqIEZhaWxzIGlmIHRoZSBzdGFjayBpcyBpbiBhIEZBSUxFRCBzdGF0ZSwgUk9MTEJBQ0sgc3RhdGUsIG9yIERFTEVURUQgc3RhdGUuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgICB0aGUgbmFtZSBvZiB0aGUgc3RhY2sgdG8gd2FpdCBmb3IgYWZ0ZXIgYW4gdXBkYXRlXG4gKlxuICogQHJldHVybnMgICAgIHRoZSBDbG91ZEZvcm1hdGlvbiBkZXNjcmlwdGlvbiBvZiB0aGUgc3RhYmlsaXplZCBzdGFjayBhZnRlciB0aGUgdXBkYXRlIGF0dGVtcHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JTdGFja0RlcGxveShcbiAgY2ZuOiBJQ2xvdWRGb3JtYXRpb25DbGllbnQsXG4gIHsgaW9Ib3N0LCBhY3Rpb24gfTogSW9NZXNzYWdpbmcsXG4gIHN0YWNrTmFtZTogc3RyaW5nLFxuKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvblN0YWNrIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0YWNrID0gYXdhaXQgc3RhYmlsaXplU3RhY2soY2ZuLCB7IGlvSG9zdCwgYWN0aW9uIH0sIHN0YWNrTmFtZSk7XG4gIGlmICghc3RhY2spIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3Qgc3RhdHVzID0gc3RhY2suc3RhY2tTdGF0dXM7XG5cbiAgaWYgKHN0YXR1cy5pc0NyZWF0aW9uRmFpbHVyZSkge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICBgVGhlIHN0YWNrIG5hbWVkICR7c3RhY2tOYW1lfSBmYWlsZWQgY3JlYXRpb24sIGl0IG1heSBuZWVkIHRvIGJlIG1hbnVhbGx5IGRlbGV0ZWQgZnJvbSB0aGUgQVdTIGNvbnNvbGU6ICR7c3RhdHVzfWAsXG4gICAgKTtcbiAgfSBlbHNlIGlmICghc3RhdHVzLmlzRGVwbG95U3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFRoZSBzdGFjayBuYW1lZCAke3N0YWNrTmFtZX0gZmFpbGVkIHRvIGRlcGxveTogJHtzdGF0dXN9YCk7XG4gIH1cblxuICByZXR1cm4gc3RhY2s7XG59XG5cbi8qKlxuICogV2FpdCBmb3IgYSBzdGFjayB0byBiZWNvbWUgc3RhYmxlIChubyBsb25nZXIgX0lOX1BST0dSRVNTKSwgcmV0dXJuaW5nIGl0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFiaWxpemVTdGFjayhcbiAgY2ZuOiBJQ2xvdWRGb3JtYXRpb25DbGllbnQsXG4gIHsgaW9Ib3N0LCBhY3Rpb24gfTogSW9NZXNzYWdpbmcsIHN0YWNrTmFtZTogc3RyaW5nLFxuKSB7XG4gIGF3YWl0IGlvSG9zdC5ub3RpZnkoZGVidWcoYWN0aW9uLCBmb3JtYXQoJ1dhaXRpbmcgZm9yIHN0YWNrICVzIHRvIGZpbmlzaCBjcmVhdGluZyBvciB1cGRhdGluZy4uLicsIHN0YWNrTmFtZSkpKTtcbiAgcmV0dXJuIHdhaXRGb3IoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHN0YWNrID0gYXdhaXQgQ2xvdWRGb3JtYXRpb25TdGFjay5sb29rdXAoY2ZuLCBzdGFja05hbWUpO1xuICAgIGlmICghc3RhY2suZXhpc3RzKSB7XG4gICAgICBhd2FpdCBpb0hvc3Qubm90aWZ5KGRlYnVnKGFjdGlvbiwgZm9ybWF0KCdTdGFjayAlcyBkb2VzIG5vdCBleGlzdCcsIHN0YWNrTmFtZSkpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBzdGFjay5zdGFja1N0YXR1cztcbiAgICBpZiAoc3RhdHVzLmlzSW5Qcm9ncmVzcykge1xuICAgICAgYXdhaXQgaW9Ib3N0Lm5vdGlmeShkZWJ1ZyhhY3Rpb24sIGZvcm1hdCgnU3RhY2sgJXMgaGFzIGFuIG9uZ29pbmcgb3BlcmF0aW9uIGluIHByb2dyZXNzIGFuZCBpcyBub3Qgc3RhYmxlICglcyknLCBzdGFja05hbWUsIHN0YXR1cykpKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMuaXNSZXZpZXdJblByb2dyZXNzKSB7XG4gICAgICAvLyBUaGlzIG1heSBoYXBwZW4gaWYgYSBzdGFjayBjcmVhdGlvbiBvcGVyYXRpb24gaXMgaW50ZXJydXB0ZWQgYmVmb3JlIHRoZSBDaGFuZ2VTZXQgZXhlY3V0aW9uIHN0YXJ0cy4gUmVjb3ZlcmluZ1xuICAgICAgLy8gZnJvbSB0aGlzIHdvdWxkIHJlcXVpcmluZyBtYW51YWwgaW50ZXJ2ZW50aW9uIChkZWxldGluZyBvciBleGVjdXRpbmcgdGhlIHBlbmRpbmcgQ2hhbmdlU2V0KSwgYW5kIGZhaWxpbmcgdG8gZG9cbiAgICAgIC8vIHNvIHdpbGwgcmVzdWx0IGluIGFuIGVuZGxlc3Mgd2FpdCBoZXJlICh0aGUgQ2hhbmdlU2V0IHdvbnQgZGVsZXRlIG9yIGV4ZWN1dGUgaXRzZWxmKS4gSW5zdGVhZCBvZiBibG9ja2luZ1xuICAgICAgLy8gXCJmb3JldmVyXCIgd2UgcHJvY2VlZCBhcyBpZiB0aGUgc3RhY2sgd2FzIGV4aXN0aW5nIGFuZCBzdGFibGUuIElmIHRoZXJlIGlzIGEgY29uY3VycmVudCBvcGVyYXRpb24gdGhhdCBqdXN0XG4gICAgICAvLyBoYXNuJ3QgZmluaXNoZWQgcHJvY2VlZGluZyBqdXN0IHlldCwgZWl0aGVyIHRoaXMgb3BlcmF0aW9uIG9yIHRoZSBjb25jdXJyZW50IG9uZSBtYXkgZmFpbCBkdWUgdG8gdGhlIG90aGVyIG9uZVxuICAgICAgLy8gaGF2aW5nIG1hZGUgcHJvZ3Jlc3MuIFdoaWNoIGlzIGZpbmUuIEkgZ3Vlc3MuXG4gICAgICBhd2FpdCBpb0hvc3Qubm90aWZ5KGRlYnVnKGFjdGlvbiwgZm9ybWF0KCdTdGFjayAlcyBpcyBpbiBSRVZJRVdfSU5fUFJPR1JFU1Mgc3RhdGUuIENvbnNpZGVyaW5nIHRoaXMgaXMgYSBzdGFibGUgc3RhdHVzICglcyknLCBzdGFja05hbWUsIHN0YXR1cykpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZSBzZXQgb2YgKGZvcm1hbCkgcGFyYW1ldGVycyB0aGF0IGhhdmUgYmVlbiBkZWNsYXJlZCBpbiBhIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVBhcmFtZXRlcnMge1xuICBwdWJsaWMgc3RhdGljIGZyb21UZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGUpIHtcbiAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyYW1ldGVycyh0ZW1wbGF0ZS5QYXJhbWV0ZXJzIHx8IHt9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBUZW1wbGF0ZVBhcmFtZXRlcj4pIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgc3RhY2sgcGFyYW1ldGVycyB0byBwYXNzIGZyb20gdGhlIGdpdmVuIGRlc2lyZWQgcGFyYW1ldGVyIHZhbHVlc1xuICAgKlxuICAgKiBXaWxsIHRocm93IGlmIHBhcmFtZXRlcnMgd2l0aG91dCBhIERlZmF1bHQgdmFsdWUgb3IgYSBQcmV2aW91cyB2YWx1ZSBhcmUgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKi9cbiAgcHVibGljIHN1cHBseUFsbCh1cGRhdGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+KTogUGFyYW1ldGVyVmFsdWVzIHtcbiAgICByZXR1cm4gbmV3IFBhcmFtZXRlclZhbHVlcyh0aGlzLnBhcmFtcywgdXBkYXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogRnJvbSB0aGUgdGVtcGxhdGUsIHRoZSBnaXZlbiBkZXNpcmVkIHZhbHVlcyBhbmQgdGhlIGN1cnJlbnQgdmFsdWVzLCBjYWxjdWxhdGUgdGhlIGNoYW5nZXMgdG8gdGhlIHN0YWNrIHBhcmFtZXRlcnNcbiAgICpcbiAgICogV2lsbCB0YWtlIGludG8gYWNjb3VudCBwYXJhbWV0ZXJzIGFscmVhZHkgc2V0IG9uIHRoZSB0ZW1wbGF0ZSAod2lsbCBlbWl0XG4gICAqICdVc2VQcmV2aW91c1ZhbHVlOiB0cnVlJyBmb3IgdGhvc2UgdW5sZXNzIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkKSwgYW5kIHdpbGxcbiAgICogdGhyb3cgaWYgcGFyYW1ldGVycyB3aXRob3V0IGEgRGVmYXVsdCB2YWx1ZSBvciBhIFByZXZpb3VzIHZhbHVlIGFyZSBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlRXhpc3RpbmcoXG4gICAgdXBkYXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPixcbiAgICBwcmV2aW91c1ZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgKTogUGFyYW1ldGVyVmFsdWVzIHtcbiAgICByZXR1cm4gbmV3IFBhcmFtZXRlclZhbHVlcyh0aGlzLnBhcmFtcywgdXBkYXRlcywgcHJldmlvdXNWYWx1ZXMpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHNldCBvZiBwYXJhbWV0ZXJzIHdlJ3JlIGdvaW5nIHRvIHBhc3MgdG8gYSBTdGFja1xuICovXG5leHBvcnQgY2xhc3MgUGFyYW1ldGVyVmFsdWVzIHtcbiAgcHVibGljIHJlYWRvbmx5IHZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBwdWJsaWMgcmVhZG9ubHkgYXBpUGFyYW1ldGVyczogUGFyYW1ldGVyW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZvcm1hbFBhcmFtczogUmVjb3JkPHN0cmluZywgVGVtcGxhdGVQYXJhbWV0ZXI+LFxuICAgIHVwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4sXG4gICAgcHJldmlvdXNWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSxcbiAgKSB7XG4gICAgY29uc3QgbWlzc2luZ1JlcXVpcmVkID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgZm9ybWFsUGFyYW1dIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZm9ybWFsUGFyYW1zKSkge1xuICAgICAgLy8gQ2hlY2sgdXBkYXRlcyBmaXJzdCwgdGhlbiB1c2UgdGhlIHByZXZpb3VzIHZhbHVlIChpZiBhdmFpbGFibGUpLCB0aGVuIHVzZVxuICAgICAgLy8gdGhlIGRlZmF1bHQgKGlmIGF2YWlsYWJsZSkuXG4gICAgICAvL1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgZmluZCBhIHBhcmFtZXRlciB2YWx1ZSB1c2luZyBhbnkgb2YgdGhlc2UgbWV0aG9kcywgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4gICAgICBjb25zdCB1cGRhdGVkVmFsdWUgPSB1cGRhdGVzW2tleV07XG4gICAgICBpZiAodXBkYXRlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IHVwZGF0ZWRWYWx1ZTtcbiAgICAgICAgdGhpcy5hcGlQYXJhbWV0ZXJzLnB1c2goe1xuICAgICAgICAgIFBhcmFtZXRlcktleToga2V5LFxuICAgICAgICAgIFBhcmFtZXRlclZhbHVlOiB1cGRhdGVzW2tleV0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSBpbiBwcmV2aW91c1ZhbHVlcykge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gcHJldmlvdXNWYWx1ZXNba2V5XTtcbiAgICAgICAgdGhpcy5hcGlQYXJhbWV0ZXJzLnB1c2goeyBQYXJhbWV0ZXJLZXk6IGtleSwgVXNlUHJldmlvdXNWYWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYWxQYXJhbS5EZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IGZvcm1hbFBhcmFtLkRlZmF1bHQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBPaCBub1xuICAgICAgbWlzc2luZ1JlcXVpcmVkLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ1JlcXVpcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFRoZSBmb2xsb3dpbmcgQ2xvdWRGb3JtYXRpb24gUGFyYW1ldGVycyBhcmUgbWlzc2luZyBhIHZhbHVlOiAke21pc3NpbmdSZXF1aXJlZC5qb2luKCcsICcpfWApO1xuICAgIH1cblxuICAgIC8vIEp1c3QgYXBwZW5kIGFsbCBzdXBwbGllZCBvdmVycmlkZXMgdGhhdCBhcmVuJ3QgcmVhbGx5IGV4cGVjdGVkICh0aGlzXG4gICAgLy8gd2lsbCBmYWlsIENGTiBidXQgbWF5YmUgcGVvcGxlIG1hZGUgdHlwb3MgdGhhdCB0aGV5IHdhbnQgdG8gYmUgbm90aWZpZWRcbiAgICAvLyBvZilcbiAgICBjb25zdCB1bmtub3duUGFyYW0gPSAoW2tleSwgX106IFtzdHJpbmcsIGFueV0pID0+IHRoaXMuZm9ybWFsUGFyYW1zW2tleV0gPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBoYXNWYWx1ZSA9IChbXywgdmFsdWVdOiBbc3RyaW5nLCBhbnldKSA9PiAhIXZhbHVlO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHVwZGF0ZXMpLmZpbHRlcih1bmtub3duUGFyYW0pLmZpbHRlcihoYXNWYWx1ZSkpIHtcbiAgICAgIHRoaXMudmFsdWVzW2tleV0gPSB2YWx1ZSE7XG4gICAgICB0aGlzLmFwaVBhcmFtZXRlcnMucHVzaCh7IFBhcmFtZXRlcktleToga2V5LCBQYXJhbWV0ZXJWYWx1ZTogdmFsdWUgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBzZXQgb2YgcGFyYW1ldGVyIHVwZGF0ZXMgd2lsbCBjaGFuZ2UgdGhlIGFjdHVhbCBzdGFjayB2YWx1ZXNcbiAgICovXG4gIHB1YmxpYyBoYXNDaGFuZ2VzKGN1cnJlbnRWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBQYXJhbWV0ZXJDaGFuZ2VzIHtcbiAgICAvLyBJZiBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgYXJlIFNTTSBwYXJhbWV0ZXJzLCBkZXBsb3lpbmcgbXVzdCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYmVjYXVzZSB3ZSBjYW4ndCBwcmVkaWN0IHdoYXQgdGhlIHZhbHVlcyB3aWxsIGJlLiBXZSB3aWxsIGFsbG93IHNvbWVcbiAgICAvLyBwYXJhbWV0ZXJzIHRvIG9wdCBvdXQgb2YgdGhpcyBjaGVjayBieSBoYXZpbmcgYSBtYWdpYyBzdHJpbmcgaW4gdGhlaXIgZGVzY3JpcHRpb24uXG4gICAgaWYgKFxuICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLmZvcm1hbFBhcmFtcykuc29tZShcbiAgICAgICAgKHApID0+IHAuVHlwZS5zdGFydHNXaXRoKCdBV1M6OlNTTTo6UGFyYW1ldGVyOjonKSAmJiAhcC5EZXNjcmlwdGlvbj8uaW5jbHVkZXMoU1NNUEFSQU1fTk9fSU5WQUxJREFURSksXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gJ3NzbSc7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlIHdlJ3JlIGRpcnR5IGlmOlxuICAgIC8vIC0gYW55IG9mIHRoZSBleGlzdGluZyB2YWx1ZXMgYXJlIHJlbW92ZWQsIG9yIGNoYW5nZWRcbiAgICBpZiAoT2JqZWN0LmVudHJpZXMoY3VycmVudFZhbHVlcykuc29tZSgoW2tleSwgdmFsdWVdKSA9PiAhKGtleSBpbiB0aGlzLnZhbHVlcykgfHwgdmFsdWUgIT09IHRoaXMudmFsdWVzW2tleV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAtIGFueSBvZiB0aGUgdmFsdWVzIHdlJ3JlIHNldHRpbmcgYXJlIG5ld1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykuc29tZSgoa2V5KSA9PiAhKGtleSBpbiBjdXJyZW50VmFsdWVzKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBQYXJhbWV0ZXJDaGFuZ2VzID0gYm9vbGVhbiB8ICdzc20nO1xuIl19