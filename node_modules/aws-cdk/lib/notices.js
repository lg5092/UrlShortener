"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachedDataSource = exports.WebsiteNoticeDataSource = exports.FilteredNotice = exports.Notices = exports.NoticesFilter = void 0;
const https = require("node:https");
const path = require("path");
const fs = require("fs-extra");
const semver = require("semver");
const awscli_compatible_1 = require("./api/aws-auth/awscli-compatible");
const version_1 = require("./cli/version");
const logging_1 = require("./logging");
const error_1 = require("./toolkit/error");
const tree_1 = require("./tree");
const directories_1 = require("./util/directories");
const format_error_1 = require("./util/format-error");
const CACHE_FILE_PATH = path.join((0, directories_1.cdkCacheDir)(), 'notices.json');
class NoticesFilter {
    static filter(options) {
        const components = [
            ...NoticesFilter.constructTreeComponents(options.outDir),
            ...NoticesFilter.otherComponents(options),
        ];
        return NoticesFilter.findForNamedComponents(options.data, components);
    }
    /**
     * From a set of input options, return the notices components we are searching for
     */
    static otherComponents(options) {
        return [
            // CLI
            {
                name: 'cli',
                version: options.cliVersion,
            },
            // Node version
            {
                name: 'node',
                version: process.version.replace(/^v/, ''), // remove the 'v' prefix.
                dynamicName: 'node',
            },
            // Bootstrap environments
            ...options.bootstrappedEnvironments.flatMap(env => {
                const semverBootstrapVersion = semver.coerce(env.bootstrapStackVersion);
                if (!semverBootstrapVersion) {
                    // we don't throw because notices should never crash the cli.
                    (0, logging_1.warning)(`While filtering notices, could not coerce bootstrap version '${env.bootstrapStackVersion}' into semver`);
                    return [];
                }
                return [{
                        name: 'bootstrap',
                        version: `${semverBootstrapVersion}`,
                        dynamicName: 'ENVIRONMENTS',
                        dynamicValue: env.environment.name,
                    }];
            }),
        ];
    }
    /**
     * Based on a set of component names, find all notices that match one of the given components
     */
    static findForNamedComponents(data, actualComponents) {
        return data.flatMap(notice => {
            const ors = this.resolveAliases(normalizeComponents(notice.components));
            // Find the first set of the disjunctions of which all components match against the actual components.
            // Return the actual components we found so that we can inject their dynamic values. A single filter
            // component can match more than one actual component
            for (const ands of ors) {
                const matched = ands.map(affected => actualComponents.filter(actual => NoticesFilter.componentNameMatches(affected, actual) && semver.satisfies(actual.version, affected.version, { includePrerelease: true })));
                // For every clause in the filter we matched one or more components
                if (matched.every(xs => xs.length > 0)) {
                    const ret = new FilteredNotice(notice);
                    NoticesFilter.addDynamicValues(matched.flatMap(x => x), ret);
                    return [ret];
                }
            }
            return [];
        });
    }
    /**
     * Whether the given "affected component" name applies to the given actual component name.
     *
     * The name matches if the name is exactly the same, or the name in the notice
     * is a prefix of the node name when the query ends in '.'.
     */
    static componentNameMatches(pattern, actual) {
        return pattern.name.endsWith('.') ? actual.name.startsWith(pattern.name) : pattern.name === actual.name;
    }
    /**
     * Adds dynamic values from the given ActualComponents
     *
     * If there are multiple components with the same dynamic name, they are joined
     * by a comma.
     */
    static addDynamicValues(comps, notice) {
        var _a, _b;
        const dynamicValues = {};
        for (const comp of comps) {
            if (comp.dynamicName) {
                dynamicValues[comp.dynamicName] = (_a = dynamicValues[comp.dynamicName]) !== null && _a !== void 0 ? _a : [];
                dynamicValues[comp.dynamicName].push((_b = comp.dynamicValue) !== null && _b !== void 0 ? _b : comp.version);
            }
        }
        for (const [key, values] of Object.entries(dynamicValues)) {
            notice.addDynamicValue(key, values.join(','));
        }
    }
    /**
     * Treat 'framework' as an alias for either `aws-cdk-lib.` or `@aws-cdk/core.`.
     *
     * Because it's EITHER `aws-cdk-lib` or `@aws-cdk/core`, we need to add multiple
     * arrays at the top level.
     */
    static resolveAliases(ors) {
        return ors.flatMap(ands => {
            const hasFramework = ands.find(c => c.name === 'framework');
            if (!hasFramework) {
                return [ands];
            }
            return [
                ands.map(c => c.name === 'framework' ? { ...c, name: '@aws-cdk/core.' } : c),
                ands.map(c => c.name === 'framework' ? { ...c, name: 'aws-cdk-lib.' } : c),
            ];
        });
    }
    /**
     * Load the construct tree from the given directory and return its components
     */
    static constructTreeComponents(manifestDir) {
        const tree = (0, tree_1.loadTreeFromDir)(manifestDir);
        if (!tree) {
            return [];
        }
        const ret = [];
        recurse(tree);
        return ret;
        function recurse(x) {
            var _a, _b, _c, _d, _e;
            if (((_a = x.constructInfo) === null || _a === void 0 ? void 0 : _a.fqn) && ((_b = x.constructInfo) === null || _b === void 0 ? void 0 : _b.version)) {
                ret.push({
                    name: (_c = x.constructInfo) === null || _c === void 0 ? void 0 : _c.fqn,
                    version: (_d = x.constructInfo) === null || _d === void 0 ? void 0 : _d.version,
                });
            }
            for (const child of Object.values((_e = x.children) !== null && _e !== void 0 ? _e : {})) {
                recurse(child);
            }
        }
    }
}
exports.NoticesFilter = NoticesFilter;
/**
 * Provides access to notices the CLI can display.
 */
class Notices {
    /**
     * Create an instance. Note that this replaces the singleton.
     */
    static create(props) {
        this._instance = new Notices(props);
        return this._instance;
    }
    /**
     * Get the singleton instance. May return `undefined` if `create` has not been called.
     */
    static get() {
        return this._instance;
    }
    constructor(props) {
        var _a, _b, _c, _d, _e;
        this.data = new Set();
        // sets don't deduplicate interfaces, so we use a map.
        this.bootstrappedEnvironments = new Map();
        this.context = props.context;
        this.acknowledgedIssueNumbers = new Set((_a = this.context.get('acknowledged-issue-numbers')) !== null && _a !== void 0 ? _a : []);
        this.includeAcknowlegded = (_b = props.includeAcknowledged) !== null && _b !== void 0 ? _b : false;
        this.output = (_c = props.output) !== null && _c !== void 0 ? _c : 'cdk.out';
        this.shouldDisplay = (_d = props.shouldDisplay) !== null && _d !== void 0 ? _d : true;
        this.httpOptions = (_e = props.httpOptions) !== null && _e !== void 0 ? _e : {};
    }
    /**
     * Add a bootstrap information to filter on. Can have multiple values
     * in case of multi-environment deployments.
     */
    addBootstrappedEnvironment(bootstrapped) {
        const key = [
            bootstrapped.bootstrapStackVersion,
            bootstrapped.environment.account,
            bootstrapped.environment.region,
            bootstrapped.environment.name,
        ].join(':');
        this.bootstrappedEnvironments.set(key, bootstrapped);
    }
    /**
     * Refresh the list of notices this instance is aware of.
     * To make sure this never crashes the CLI process, all failures are caught and
     * silently logged.
     *
     * If context is configured to not display notices, this will no-op.
     */
    async refresh(options = {}) {
        var _a, _b;
        if (!this.shouldDisplay) {
            return;
        }
        try {
            const underlyingDataSource = (_a = options.dataSource) !== null && _a !== void 0 ? _a : new WebsiteNoticeDataSource(this.httpOptions);
            const dataSource = new CachedDataSource(CACHE_FILE_PATH, underlyingDataSource, (_b = options.force) !== null && _b !== void 0 ? _b : false);
            const notices = await dataSource.fetch();
            this.data = new Set(this.includeAcknowlegded ? notices : notices.filter(n => !this.acknowledgedIssueNumbers.has(n.issueNumber)));
        }
        catch (e) {
            (0, logging_1.debug)(`Could not refresh notices: ${e}`);
        }
    }
    /**
     * Display the relevant notices (unless context dictates we shouldn't).
     */
    display(options = {}) {
        var _a;
        if (!this.shouldDisplay) {
            return;
        }
        const filteredNotices = NoticesFilter.filter({
            data: Array.from(this.data),
            cliVersion: (0, version_1.versionNumber)(),
            outDir: this.output,
            bootstrappedEnvironments: Array.from(this.bootstrappedEnvironments.values()),
        });
        if (filteredNotices.length > 0) {
            (0, logging_1.info)('');
            (0, logging_1.info)('NOTICES         (What\'s this? https://github.com/aws/aws-cdk/wiki/CLI-Notices)');
            (0, logging_1.info)('');
            for (const filtered of filteredNotices) {
                const formatted = filtered.format();
                switch (filtered.notice.severity) {
                    case 'warning':
                        (0, logging_1.warning)(formatted);
                        break;
                    case 'error':
                        (0, logging_1.error)(formatted);
                        break;
                    default:
                        (0, logging_1.info)(formatted);
                }
                (0, logging_1.info)('');
            }
            (0, logging_1.info)(`If you don’t want to see a notice anymore, use "cdk acknowledge <id>". For example, "cdk acknowledge ${filteredNotices[0].notice.issueNumber}".`);
        }
        if ((_a = options.showTotal) !== null && _a !== void 0 ? _a : false) {
            (0, logging_1.info)('');
            (0, logging_1.info)(`There are ${filteredNotices.length} unacknowledged notice(s).`);
        }
    }
}
exports.Notices = Notices;
/**
 * Normalizes the given components structure into DNF form
 */
function normalizeComponents(xs) {
    return xs.map(x => Array.isArray(x) ? x : [x]);
}
function renderConjunction(xs) {
    return xs.map(c => `${c.name}: ${c.version}`).join(' AND ');
}
/**
 * Notice after passing the filter. A filter can augment a notice with
 * dynamic values as it has access to the dynamic matching data.
 */
class FilteredNotice {
    constructor(notice) {
        this.notice = notice;
        this.dynamicValues = {};
    }
    addDynamicValue(key, value) {
        this.dynamicValues[`{resolve:${key}}`] = value;
    }
    format() {
        const componentsValue = normalizeComponents(this.notice.components).map(renderConjunction).join(', ');
        return this.resolveDynamicValues([
            `${this.notice.issueNumber}\t${this.notice.title}`,
            this.formatOverview(),
            `\tAffected versions: ${componentsValue}`,
            `\tMore information at: https://github.com/aws/aws-cdk/issues/${this.notice.issueNumber}`,
        ].join('\n\n') + '\n');
    }
    formatOverview() {
        const wrap = (s) => s.replace(/(?![^\n]{1,60}$)([^\n]{1,60})\s/g, '$1\n');
        const heading = 'Overview: ';
        const separator = `\n\t${' '.repeat(heading.length)}`;
        const content = wrap(this.notice.overview)
            .split('\n')
            .join(separator);
        return '\t' + heading + content;
    }
    resolveDynamicValues(input) {
        const pattern = new RegExp(Object.keys(this.dynamicValues).join('|'), 'g');
        return input.replace(pattern, (matched) => { var _a; return (_a = this.dynamicValues[matched]) !== null && _a !== void 0 ? _a : matched; });
    }
}
exports.FilteredNotice = FilteredNotice;
class WebsiteNoticeDataSource {
    constructor(options = {}) {
        this.options = options;
    }
    fetch() {
        const timeout = 3000;
        return new Promise((resolve, reject) => {
            let req;
            let timer = setTimeout(() => {
                if (req) {
                    req.destroy(new error_1.ToolkitError('Request timed out'));
                }
            }, timeout);
            timer.unref();
            const options = {
                agent: awscli_compatible_1.AwsCliCompatible.proxyAgent(this.options),
            };
            try {
                req = https.get('https://cli.cdk.dev-tools.aws.dev/notices.json', options, res => {
                    if (res.statusCode === 200) {
                        res.setEncoding('utf8');
                        let rawData = '';
                        res.on('data', (chunk) => {
                            rawData += chunk;
                        });
                        res.on('end', () => {
                            try {
                                const data = JSON.parse(rawData).notices;
                                if (!data) {
                                    throw new error_1.ToolkitError("'notices' key is missing");
                                }
                                (0, logging_1.debug)('Notices refreshed');
                                resolve(data !== null && data !== void 0 ? data : []);
                            }
                            catch (e) {
                                reject(new error_1.ToolkitError(`Failed to parse notices: ${(0, format_error_1.formatErrorMessage)(e)}`));
                            }
                        });
                        res.on('error', e => {
                            reject(new error_1.ToolkitError(`Failed to fetch notices: ${(0, format_error_1.formatErrorMessage)(e)}`));
                        });
                    }
                    else {
                        reject(new error_1.ToolkitError(`Failed to fetch notices. Status code: ${res.statusCode}`));
                    }
                });
                req.on('error', reject);
            }
            catch (e) {
                reject(new error_1.ToolkitError(`HTTPS 'get' call threw an error: ${(0, format_error_1.formatErrorMessage)(e)}`));
            }
        });
    }
}
exports.WebsiteNoticeDataSource = WebsiteNoticeDataSource;
const TIME_TO_LIVE_SUCCESS = 60 * 60 * 1000; // 1 hour
const TIME_TO_LIVE_ERROR = 1 * 60 * 1000; // 1 minute
class CachedDataSource {
    constructor(fileName, dataSource, skipCache) {
        this.fileName = fileName;
        this.dataSource = dataSource;
        this.skipCache = skipCache;
    }
    async fetch() {
        var _a;
        const cachedData = await this.load();
        const data = cachedData.notices;
        const expiration = (_a = cachedData.expiration) !== null && _a !== void 0 ? _a : 0;
        if (Date.now() > expiration || this.skipCache) {
            const freshData = await this.fetchInner();
            await this.save(freshData);
            return freshData.notices;
        }
        else {
            (0, logging_1.debug)(`Reading cached notices from ${this.fileName}`);
            return data;
        }
    }
    async fetchInner() {
        try {
            return {
                expiration: Date.now() + TIME_TO_LIVE_SUCCESS,
                notices: await this.dataSource.fetch(),
            };
        }
        catch (e) {
            (0, logging_1.debug)(`Could not refresh notices: ${e}`);
            return {
                expiration: Date.now() + TIME_TO_LIVE_ERROR,
                notices: [],
            };
        }
    }
    async load() {
        const defaultValue = {
            expiration: 0,
            notices: [],
        };
        try {
            return fs.existsSync(this.fileName)
                ? await fs.readJSON(this.fileName)
                : defaultValue;
        }
        catch (e) {
            (0, logging_1.debug)(`Failed to load notices from cache: ${e}`);
            return defaultValue;
        }
    }
    async save(cached) {
        try {
            await fs.writeJSON(this.fileName, cached);
        }
        catch (e) {
            (0, logging_1.debug)(`Failed to store notices in the cache: ${e}`);
        }
    }
}
exports.CachedDataSource = CachedDataSource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90aWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5vdGljZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsb0NBQW9DO0FBQ3BDLDZCQUE2QjtBQUU3QiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBRWpDLHdFQUFvRTtBQUVwRSwyQ0FBOEM7QUFDOUMsdUNBQXdEO0FBQ3hELDJDQUErQztBQUMvQyxpQ0FBNEQ7QUFDNUQsb0RBQWlEO0FBQ2pELHNEQUF5RDtBQUV6RCxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUEseUJBQVcsR0FBRSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0FBb0VqRSxNQUFzQixhQUFhO0lBQzFCLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBbUM7UUFDdEQsTUFBTSxVQUFVLEdBQUc7WUFDakIsR0FBRyxhQUFhLENBQUMsdUJBQXVCLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUN4RCxHQUFHLGFBQWEsQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDO1NBQzFDLENBQUM7UUFFRixPQUFPLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRDs7T0FFRztJQUNLLE1BQU0sQ0FBQyxlQUFlLENBQUMsT0FBbUM7UUFDaEUsT0FBTztZQUNMLE1BQU07WUFDTjtnQkFDRSxJQUFJLEVBQUUsS0FBSztnQkFDWCxPQUFPLEVBQUUsT0FBTyxDQUFDLFVBQVU7YUFDNUI7WUFFRCxlQUFlO1lBQ2Y7Z0JBQ0UsSUFBSSxFQUFFLE1BQU07Z0JBQ1osT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSx5QkFBeUI7Z0JBQ3JFLFdBQVcsRUFBRSxNQUFNO2FBQ3BCO1lBRUQseUJBQXlCO1lBQ3pCLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxHQUFH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QyxPQUFPLEVBQUUsRUFBRTthQUNaLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVPLEtBQUssQ0FBQyxJQUFJO1FBQ2hCLE1BQU0sWUFBWSxHQUFHO1lBQ25CLFVBQVUsRUFBRSxDQUFDO1lBQ2IsT0FBTyxFQUFFLEVBQUU7U0FDWixDQUFDO1FBRUYsSUFBSSxDQUFDO1lBQ0gsT0FBTyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7Z0JBQ2pDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBa0I7Z0JBQ25ELENBQUMsQ0FBQyxZQUFZLENBQUM7UUFDbkIsQ0FBQztRQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFDWCxJQUFBLGVBQUssRUFBQyxzQ0FBc0MsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNqRCxPQUFPLFlBQVksQ0FBQztRQUN0QixDQUFDO0lBQ0gsQ0FBQztJQUVPLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBcUI7UUFDdEMsSUFBSSxDQUFDO1lBQ0gsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFDWCxJQUFBLGVBQUssRUFBQyx5Q0FBeUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN0RCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBNURELDRDQTREQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENsaWVudFJlcXVlc3QgfSBmcm9tICdodHRwJztcbmltcG9ydCB7IFJlcXVlc3RPcHRpb25zIH0gZnJvbSAnaHR0cHMnO1xuaW1wb3J0ICogYXMgaHR0cHMgZnJvbSAnbm9kZTpodHRwcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHR5cGUgeyBFbnZpcm9ubWVudCB9IGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCB7IFNka0h0dHBPcHRpb25zIH0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHsgQXdzQ2xpQ29tcGF0aWJsZSB9IGZyb20gJy4vYXBpL2F3cy1hdXRoL2F3c2NsaS1jb21wYXRpYmxlJztcbmltcG9ydCB0eXBlIHsgQ29udGV4dCB9IGZyb20gJy4vYXBpL2NvbnRleHQnO1xuaW1wb3J0IHsgdmVyc2lvbk51bWJlciB9IGZyb20gJy4vY2xpL3ZlcnNpb24nO1xuaW1wb3J0IHsgZGVidWcsIGluZm8sIHdhcm5pbmcsIGVycm9yIH0gZnJvbSAnLi9sb2dnaW5nJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4vdG9vbGtpdC9lcnJvcic7XG5pbXBvcnQgeyBDb25zdHJ1Y3RUcmVlTm9kZSwgbG9hZFRyZWVGcm9tRGlyIH0gZnJvbSAnLi90cmVlJztcbmltcG9ydCB7IGNka0NhY2hlRGlyIH0gZnJvbSAnLi91dGlsL2RpcmVjdG9yaWVzJztcbmltcG9ydCB7IGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gJy4vdXRpbC9mb3JtYXQtZXJyb3InO1xuXG5jb25zdCBDQUNIRV9GSUxFX1BBVEggPSBwYXRoLmpvaW4oY2RrQ2FjaGVEaXIoKSwgJ25vdGljZXMuanNvbicpO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZXNQcm9wcyB7XG4gIC8qKlxuICAgKiBDREsgY29udGV4dFxuICAgKi9cbiAgcmVhZG9ubHkgY29udGV4dDogQ29udGV4dDtcblxuICAvKipcbiAgICogSW5jbHVkZSBub3RpY2VzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYWNrbm93bGVkZ2VkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgaW5jbHVkZUFja25vd2xlZGdlZD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdsb2JhbCBDTEkgb3B0aW9uIGZvciBvdXRwdXQgZGlyZWN0b3J5IGZvciBzeW50aGVzaXplZCBjbG91ZCBhc3NlbWJseVxuICAgKlxuICAgKiBAZGVmYXVsdCAnY2RrLm91dCdcbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dD86IHN0cmluZztcblxuICAvKipcbiAgICogR2xvYmFsIENMSSBvcHRpb24gZm9yIHdoZXRoZXIgd2Ugc2hvdyBub3RpY2VzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHNob3VsZERpc3BsYXk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciB0aGUgSFRUUCByZXF1ZXN0XG4gICAqL1xuICByZWFkb25seSBodHRwT3B0aW9ucz86IFNka0h0dHBPcHRpb25zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZXNQcmludE9wdGlvbnMge1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGFwcGVuZCB0aGUgdG90YWwgbnVtYmVyIG9mIHVuYWNrbm93bGVkZ2VkIG5vdGljZXMgdG8gdGhlIGRpc3BsYXkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBzaG93VG90YWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZXNSZWZyZXNoT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGZvcmNlIGEgY2FjaGUgcmVmcmVzaCByZWdhcmRsZXNzIG9mIGV4cGlyYXRpb24gdGltZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGZvcmNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGF0YSBzb3VyY2UgZm9yIGZldGNoIG5vdGljZXMgZnJvbS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBXZWJzaXRlTm90aWNlRGF0YVNvdXJjZVxuICAgKi9cbiAgcmVhZG9ubHkgZGF0YVNvdXJjZT86IE5vdGljZURhdGFTb3VyY2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlc0ZpbHRlckZpbHRlck9wdGlvbnMge1xuICByZWFkb25seSBkYXRhOiBOb3RpY2VbXTtcbiAgcmVhZG9ubHkgY2xpVmVyc2lvbjogc3RyaW5nO1xuICByZWFkb25seSBvdXREaXI6IHN0cmluZztcbiAgcmVhZG9ubHkgYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzOiBCb290c3RyYXBwZWRFbnZpcm9ubWVudFtdO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTm90aWNlc0ZpbHRlciB7XG4gIHB1YmxpYyBzdGF0aWMgZmlsdGVyKG9wdGlvbnM6IE5vdGljZXNGaWx0ZXJGaWx0ZXJPcHRpb25zKTogRmlsdGVyZWROb3RpY2VbXSB7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtcbiAgICAgIC4uLk5vdGljZXNGaWx0ZXIuY29uc3RydWN0VHJlZUNvbXBvbmVudHMob3B0aW9ucy5vdXREaXIpLFxuICAgICAgLi4uTm90aWNlc0ZpbHRlci5vdGhlckNvbXBvbmVudHMob3B0aW9ucyksXG4gICAgXTtcblxuICAgIHJldHVybiBOb3RpY2VzRmlsdGVyLmZpbmRGb3JOYW1lZENvbXBvbmVudHMob3B0aW9ucy5kYXRhLCBjb21wb25lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcm9tIGEgc2V0IG9mIGlucHV0IG9wdGlvbnMsIHJldHVybiB0aGUgbm90aWNlcyBjb21wb25lbnRzIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBvdGhlckNvbXBvbmVudHMob3B0aW9uczogTm90aWNlc0ZpbHRlckZpbHRlck9wdGlvbnMpOiBBY3R1YWxDb21wb25lbnRbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIENMSVxuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpJyxcbiAgICAgICAgdmVyc2lvbjogb3B0aW9ucy5jbGlWZXJzaW9uLFxuICAgICAgfSxcblxuICAgICAgLy8gTm9kZSB2ZXJzaW9uXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdub2RlJyxcbiAgICAgICAgdmVyc2lvbjogcHJvY2Vzcy52ZXJzaW9uLnJlcGxhY2UoL152LywgJycpLCAvLyByZW1vdmUgdGhlICd2JyBwcmVmaXguXG4gICAgICAgIGR5bmFtaWNOYW1lOiAnbm9kZScsXG4gICAgICB9LFxuXG4gICAgICAvLyBCb290c3RyYXAgZW52aXJvbm1lbnRzXG4gICAgICAuLi5vcHRpb25zLmJvb3RzdHJhcHBlZEVudmlyb25tZW50cy5mbGF0TWFwKGVudiA9PiB7XG4gICAgICAgIGNvbnN0IHNlbXZlckJvb3RzdHJhcFZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGVudi5ib290c3RyYXBTdGFja1ZlcnNpb24pO1xuICAgICAgICBpZiAoIXNlbXZlckJvb3RzdHJhcFZlcnNpb24pIHtcbiAgICAgICAgICAvLyB3ZSBkb24ndCB0aHJvdyBiZWNhdXNlIG5vdGljZXMgc2hvdWxkIG5ldmVyIGNyYXNoIHRoZSBjbGkuXG4gICAgICAgICAgd2FybmluZyhgV2hpbGUgZmlsdGVyaW5nIG5vdGljZXMsIGNvdWxkIG5vdCBjb2VyY2UgYm9vdHN0cmFwIHZlcnNpb24gJyR7ZW52LmJvb3RzdHJhcFN0YWNrVmVyc2lvbn0nIGludG8gc2VtdmVyYCk7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgbmFtZTogJ2Jvb3RzdHJhcCcsXG4gICAgICAgICAgdmVyc2lvbjogYCR7c2VtdmVyQm9vdHN0cmFwVmVyc2lvbn1gLFxuICAgICAgICAgIGR5bmFtaWNOYW1lOiAnRU5WSVJPTk1FTlRTJyxcbiAgICAgICAgICBkeW5hbWljVmFsdWU6IGVudi5lbnZpcm9ubWVudC5uYW1lLFxuICAgICAgICB9XTtcbiAgICAgIH0pLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQmFzZWQgb24gYSBzZXQgb2YgY29tcG9uZW50IG5hbWVzLCBmaW5kIGFsbCBub3RpY2VzIHRoYXQgbWF0Y2ggb25lIG9mIHRoZSBnaXZlbiBjb21wb25lbnRzXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBmaW5kRm9yTmFtZWRDb21wb25lbnRzKGRhdGE6IE5vdGljZVtdLCBhY3R1YWxDb21wb25lbnRzOiBBY3R1YWxDb21wb25lbnRbXSk6IEZpbHRlcmVkTm90aWNlW10ge1xuICAgIHJldHVybiBkYXRhLmZsYXRNYXAobm90aWNlID0+IHtcbiAgICAgIGNvbnN0IG9ycyA9IHRoaXMucmVzb2x2ZUFsaWFzZXMobm9ybWFsaXplQ29tcG9uZW50cyhub3RpY2UuY29tcG9uZW50cykpO1xuXG4gICAgICAvLyBGaW5kIHRoZSBmaXJzdCBzZXQgb2YgdGhlIGRpc2p1bmN0aW9ucyBvZiB3aGljaCBhbGwgY29tcG9uZW50cyBtYXRjaCBhZ2FpbnN0IHRoZSBhY3R1YWwgY29tcG9uZW50cy5cbiAgICAgIC8vIFJldHVybiB0aGUgYWN0dWFsIGNvbXBvbmVudHMgd2UgZm91bmQgc28gdGhhdCB3ZSBjYW4gaW5qZWN0IHRoZWlyIGR5bmFtaWMgdmFsdWVzLiBBIHNpbmdsZSBmaWx0ZXJcbiAgICAgIC8vIGNvbXBvbmVudCBjYW4gbWF0Y2ggbW9yZSB0aGFuIG9uZSBhY3R1YWwgY29tcG9uZW50XG4gICAgICBmb3IgKGNvbnN0IGFuZHMgb2Ygb3JzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZWQgPSBhbmRzLm1hcChhZmZlY3RlZCA9PiBhY3R1YWxDb21wb25lbnRzLmZpbHRlcihhY3R1YWwgPT5cbiAgICAgICAgICBOb3RpY2VzRmlsdGVyLmNvbXBvbmVudE5hbWVNYXRjaGVzKGFmZmVjdGVkLCBhY3R1YWwpICYmIHNlbXZlci5zYXRpc2ZpZXMoYWN0dWFsLnZlcnNpb24sIGFmZmVjdGVkLnZlcnNpb24sIHsgaW5jbHVkZVByZXJlbGVhc2U6IHRydWUgfSkpKTtcblxuICAgICAgICAvLyBGb3IgZXZlcnkgY2xhdXNlIGluIHRoZSBmaWx0ZXIgd2UgbWF0Y2hlZCBvbmUgb3IgbW9yZSBjb21wb25lbnRzXG4gICAgICAgIGlmIChtYXRjaGVkLmV2ZXJ5KHhzID0+IHhzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgY29uc3QgcmV0ID0gbmV3IEZpbHRlcmVkTm90aWNlKG5vdGljZSk7XG4gICAgICAgICAgTm90aWNlc0ZpbHRlci5hZGREeW5hbWljVmFsdWVzKG1hdGNoZWQuZmxhdE1hcCh4ID0+IHgpLCByZXQpO1xuICAgICAgICAgIHJldHVybiBbcmV0XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZ2l2ZW4gXCJhZmZlY3RlZCBjb21wb25lbnRcIiBuYW1lIGFwcGxpZXMgdG8gdGhlIGdpdmVuIGFjdHVhbCBjb21wb25lbnQgbmFtZS5cbiAgICpcbiAgICogVGhlIG5hbWUgbWF0Y2hlcyBpZiB0aGUgbmFtZSBpcyBleGFjdGx5IHRoZSBzYW1lLCBvciB0aGUgbmFtZSBpbiB0aGUgbm90aWNlXG4gICAqIGlzIGEgcHJlZml4IG9mIHRoZSBub2RlIG5hbWUgd2hlbiB0aGUgcXVlcnkgZW5kcyBpbiAnLicuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBjb21wb25lbnROYW1lTWF0Y2hlcyhwYXR0ZXJuOiBDb21wb25lbnQsIGFjdHVhbDogQWN0dWFsQ29tcG9uZW50KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHBhdHRlcm4ubmFtZS5lbmRzV2l0aCgnLicpID8gYWN0dWFsLm5hbWUuc3RhcnRzV2l0aChwYXR0ZXJuLm5hbWUpIDogcGF0dGVybi5uYW1lID09PSBhY3R1YWwubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGR5bmFtaWMgdmFsdWVzIGZyb20gdGhlIGdpdmVuIEFjdHVhbENvbXBvbmVudHNcbiAgICpcbiAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBkeW5hbWljIG5hbWUsIHRoZXkgYXJlIGpvaW5lZFxuICAgKiBieSBhIGNvbW1hLlxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgYWRkRHluYW1pY1ZhbHVlcyhjb21wczogQWN0dWFsQ29tcG9uZW50W10sIG5vdGljZTogRmlsdGVyZWROb3RpY2UpIHtcbiAgICBjb25zdCBkeW5hbWljVmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgY29tcHMpIHtcbiAgICAgIGlmIChjb21wLmR5bmFtaWNOYW1lKSB7XG4gICAgICAgIGR5bmFtaWNWYWx1ZXNbY29tcC5keW5hbWljTmFtZV0gPSBkeW5hbWljVmFsdWVzW2NvbXAuZHluYW1pY05hbWVdID8/IFtdO1xuICAgICAgICBkeW5hbWljVmFsdWVzW2NvbXAuZHluYW1pY05hbWVdLnB1c2goY29tcC5keW5hbWljVmFsdWUgPz8gY29tcC52ZXJzaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIE9iamVjdC5lbnRyaWVzKGR5bmFtaWNWYWx1ZXMpKSB7XG4gICAgICBub3RpY2UuYWRkRHluYW1pY1ZhbHVlKGtleSwgdmFsdWVzLmpvaW4oJywnKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyZWF0ICdmcmFtZXdvcmsnIGFzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGF3cy1jZGstbGliLmAgb3IgYEBhd3MtY2RrL2NvcmUuYC5cbiAgICpcbiAgICogQmVjYXVzZSBpdCdzIEVJVEhFUiBgYXdzLWNkay1saWJgIG9yIGBAYXdzLWNkay9jb3JlYCwgd2UgbmVlZCB0byBhZGQgbXVsdGlwbGVcbiAgICogYXJyYXlzIGF0IHRoZSB0b3AgbGV2ZWwuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyByZXNvbHZlQWxpYXNlcyhvcnM6IENvbXBvbmVudFtdW10pOiBDb21wb25lbnRbXVtdIHtcbiAgICByZXR1cm4gb3JzLmZsYXRNYXAoYW5kcyA9PiB7XG4gICAgICBjb25zdCBoYXNGcmFtZXdvcmsgPSBhbmRzLmZpbmQoYyA9PiBjLm5hbWUgPT09ICdmcmFtZXdvcmsnKTtcbiAgICAgIGlmICghaGFzRnJhbWV3b3JrKSB7XG4gICAgICAgIHJldHVybiBbYW5kc107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIGFuZHMubWFwKGMgPT4gYy5uYW1lID09PSAnZnJhbWV3b3JrJyA/IHsgLi4uYywgbmFtZTogJ0Bhd3MtY2RrL2NvcmUuJyB9IDogYyksXG4gICAgICAgIGFuZHMubWFwKGMgPT4gYy5uYW1lID09PSAnZnJhbWV3b3JrJyA/IHsgLi4uYywgbmFtZTogJ2F3cy1jZGstbGliLicgfSA6IGMpLFxuICAgICAgXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBjb25zdHJ1Y3QgdHJlZSBmcm9tIHRoZSBnaXZlbiBkaXJlY3RvcnkgYW5kIHJldHVybiBpdHMgY29tcG9uZW50c1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgY29uc3RydWN0VHJlZUNvbXBvbmVudHMobWFuaWZlc3REaXI6IHN0cmluZyk6IEFjdHVhbENvbXBvbmVudFtdIHtcbiAgICBjb25zdCB0cmVlID0gbG9hZFRyZWVGcm9tRGlyKG1hbmlmZXN0RGlyKTtcbiAgICBpZiAoIXRyZWUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCByZXQ6IEFjdHVhbENvbXBvbmVudFtdID0gW107XG4gICAgcmVjdXJzZSh0cmVlKTtcbiAgICByZXR1cm4gcmV0O1xuXG4gICAgZnVuY3Rpb24gcmVjdXJzZSh4OiBDb25zdHJ1Y3RUcmVlTm9kZSkge1xuICAgICAgaWYgKHguY29uc3RydWN0SW5mbz8uZnFuICYmIHguY29uc3RydWN0SW5mbz8udmVyc2lvbikge1xuICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgbmFtZTogeC5jb25zdHJ1Y3RJbmZvPy5mcW4sXG4gICAgICAgICAgdmVyc2lvbjogeC5jb25zdHJ1Y3RJbmZvPy52ZXJzaW9uLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBPYmplY3QudmFsdWVzKHguY2hpbGRyZW4gPz8ge30pKSB7XG4gICAgICAgIHJlY3Vyc2UoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pbnRlcmZhY2UgQWN0dWFsQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBWZXJzaW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcblxuICAvKipcbiAgICogSWYgbWF0Y2hlZCwgdW5kZXIgd2hhdCBuYW1lIHNob3VsZCBpdCBiZSBhZGRlZCB0byB0aGUgc2V0IG9mIGR5bmFtaWMgdmFsdWVzXG4gICAqXG4gICAqIFRoZXNlIHdpbGwgYmUgdXNlZCB0byBzdWJzdGl0dXRlIHBsYWNlaG9sZGVycyBpbiB0aGUgbWVzc2FnZSBzdHJpbmcsIHdoZXJlXG4gICAqIHBsYWNlaG9sZGVycyBsb29rIGxpa2UgYHtyZXNvbHZlOlhZWn1gLlxuICAgKlxuICAgKiBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIGR5bmFtaWMgbmFtZSwgdGhleSBhcmVcbiAgICogam9pbmVkIGJ5ICcsJy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEb24ndCBhZGQgdG8gdGhlIHNldCBvZiBkeW5hbWljIHZhbHVlcy5cbiAgICovXG4gIHJlYWRvbmx5IGR5bmFtaWNOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJZiBtYXRjaGVkLCB3aGF0IHdlIHNob3VsZCBwdXQgaW4gdGhlIHNldCBvZiBkeW5hbWljIHZhbHVlcyBpbnNzdGVhZCBvZiB0aGUgdmVyc2lvbi5cbiAgICpcbiAgICogT25seSB1c2VkIGlmIGBkeW5hbWljTmFtZWAgaXMgc2V0OyBieSBkZWZhdWx0IHdlIHdpbGwgYWRkIHRoZSBhY3R1YWwgdmVyc2lvblxuICAgKiBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFRoZSB2ZXJzaW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgZHluYW1pY1ZhbHVlPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IGEgYm9vdHN0cmFwcGVkIGVudmlyb25tZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJvb3RzdHJhcHBlZEVudmlyb25tZW50IHtcbiAgcmVhZG9ubHkgYm9vdHN0cmFwU3RhY2tWZXJzaW9uOiBudW1iZXI7XG4gIHJlYWRvbmx5IGVudmlyb25tZW50OiBFbnZpcm9ubWVudDtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gbm90aWNlcyB0aGUgQ0xJIGNhbiBkaXNwbGF5LlxuICovXG5leHBvcnQgY2xhc3MgTm90aWNlcyB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGlzIHJlcGxhY2VzIHRoZSBzaW5nbGV0b24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZShwcm9wczogTm90aWNlc1Byb3BzKTogTm90aWNlcyB7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgTm90aWNlcyhwcm9wcyk7XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2luZ2xldG9uIGluc3RhbmNlLiBNYXkgcmV0dXJuIGB1bmRlZmluZWRgIGlmIGBjcmVhdGVgIGhhcyBub3QgYmVlbiBjYWxsZWQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCgpOiBOb3RpY2VzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfaW5zdGFuY2U6IE5vdGljZXMgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBjb250ZXh0OiBDb250ZXh0O1xuICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dDogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IHNob3VsZERpc3BsYXk6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzOiBTZXQ8TnVtYmVyPjtcbiAgcHJpdmF0ZSByZWFkb25seSBpbmNsdWRlQWNrbm93bGVnZGVkOiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IGh0dHBPcHRpb25zOiBTZGtIdHRwT3B0aW9ucztcblxuICBwcml2YXRlIGRhdGE6IFNldDxOb3RpY2U+ID0gbmV3IFNldCgpO1xuXG4gIC8vIHNldHMgZG9uJ3QgZGVkdXBsaWNhdGUgaW50ZXJmYWNlcywgc28gd2UgdXNlIGEgbWFwLlxuICBwcml2YXRlIHJlYWRvbmx5IGJvb3RzdHJhcHBlZEVudmlyb25tZW50czogTWFwPHN0cmluZywgQm9vdHN0cmFwcGVkRW52aXJvbm1lbnQ+ID0gbmV3IE1hcCgpO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJvcHM6IE5vdGljZXNQcm9wcykge1xuICAgIHRoaXMuY29udGV4dCA9IHByb3BzLmNvbnRleHQ7XG4gICAgdGhpcy5hY2tub3dsZWRnZWRJc3N1ZU51bWJlcnMgPSBuZXcgU2V0KHRoaXMuY29udGV4dC5nZXQoJ2Fja25vd2xlZGdlZC1pc3N1ZS1udW1iZXJzJykgPz8gW10pO1xuICAgIHRoaXMuaW5jbHVkZUFja25vd2xlZ2RlZCA9IHByb3BzLmluY2x1ZGVBY2tub3dsZWRnZWQgPz8gZmFsc2U7XG4gICAgdGhpcy5vdXRwdXQgPSBwcm9wcy5vdXRwdXQgPz8gJ2Nkay5vdXQnO1xuICAgIHRoaXMuc2hvdWxkRGlzcGxheSA9IHByb3BzLnNob3VsZERpc3BsYXkgPz8gdHJ1ZTtcbiAgICB0aGlzLmh0dHBPcHRpb25zID0gcHJvcHMuaHR0cE9wdGlvbnMgPz8ge307XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgYm9vdHN0cmFwIGluZm9ybWF0aW9uIHRvIGZpbHRlciBvbi4gQ2FuIGhhdmUgbXVsdGlwbGUgdmFsdWVzXG4gICAqIGluIGNhc2Ugb2YgbXVsdGktZW52aXJvbm1lbnQgZGVwbG95bWVudHMuXG4gICAqL1xuICBwdWJsaWMgYWRkQm9vdHN0cmFwcGVkRW52aXJvbm1lbnQoYm9vdHN0cmFwcGVkOiBCb290c3RyYXBwZWRFbnZpcm9ubWVudCkge1xuICAgIGNvbnN0IGtleSA9IFtcbiAgICAgIGJvb3RzdHJhcHBlZC5ib290c3RyYXBTdGFja1ZlcnNpb24sXG4gICAgICBib290c3RyYXBwZWQuZW52aXJvbm1lbnQuYWNjb3VudCxcbiAgICAgIGJvb3RzdHJhcHBlZC5lbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBib290c3RyYXBwZWQuZW52aXJvbm1lbnQubmFtZSxcbiAgICBdLmpvaW4oJzonKTtcbiAgICB0aGlzLmJvb3RzdHJhcHBlZEVudmlyb25tZW50cy5zZXQoa2V5LCBib290c3RyYXBwZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGxpc3Qgb2Ygbm90aWNlcyB0aGlzIGluc3RhbmNlIGlzIGF3YXJlIG9mLlxuICAgKiBUbyBtYWtlIHN1cmUgdGhpcyBuZXZlciBjcmFzaGVzIHRoZSBDTEkgcHJvY2VzcywgYWxsIGZhaWx1cmVzIGFyZSBjYXVnaHQgYW5kXG4gICAqIHNpbGVudGx5IGxvZ2dlZC5cbiAgICpcbiAgICogSWYgY29udGV4dCBpcyBjb25maWd1cmVkIHRvIG5vdCBkaXNwbGF5IG5vdGljZXMsIHRoaXMgd2lsbCBuby1vcC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyByZWZyZXNoKG9wdGlvbnM6IE5vdGljZXNSZWZyZXNoT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnNob3VsZERpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdW5kZXJseWluZ0RhdGFTb3VyY2UgPSBvcHRpb25zLmRhdGFTb3VyY2UgPz8gbmV3IFdlYnNpdGVOb3RpY2VEYXRhU291cmNlKHRoaXMuaHR0cE9wdGlvbnMpO1xuICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IG5ldyBDYWNoZWREYXRhU291cmNlKENBQ0hFX0ZJTEVfUEFUSCwgdW5kZXJseWluZ0RhdGFTb3VyY2UsIG9wdGlvbnMuZm9yY2UgPz8gZmFsc2UpO1xuICAgICAgY29uc3Qgbm90aWNlcyA9IGF3YWl0IGRhdGFTb3VyY2UuZmV0Y2goKTtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBTZXQodGhpcy5pbmNsdWRlQWNrbm93bGVnZGVkID8gbm90aWNlcyA6IG5vdGljZXMuZmlsdGVyKG4gPT4gIXRoaXMuYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzLmhhcyhuLmlzc3VlTnVtYmVyKSkpO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgZGVidWcoYENvdWxkIG5vdCByZWZyZXNoIG5vdGljZXM6ICR7ZX1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheSB0aGUgcmVsZXZhbnQgbm90aWNlcyAodW5sZXNzIGNvbnRleHQgZGljdGF0ZXMgd2Ugc2hvdWxkbid0KS5cbiAgICovXG4gIHB1YmxpYyBkaXNwbGF5KG9wdGlvbnM6IE5vdGljZXNQcmludE9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5zaG91bGREaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWROb3RpY2VzID0gTm90aWNlc0ZpbHRlci5maWx0ZXIoe1xuICAgICAgZGF0YTogQXJyYXkuZnJvbSh0aGlzLmRhdGEpLFxuICAgICAgY2xpVmVyc2lvbjogdmVyc2lvbk51bWJlcigpLFxuICAgICAgb3V0RGlyOiB0aGlzLm91dHB1dCxcbiAgICAgIGJvb3RzdHJhcHBlZEVudmlyb25tZW50czogQXJyYXkuZnJvbSh0aGlzLmJvb3RzdHJhcHBlZEVudmlyb25tZW50cy52YWx1ZXMoKSksXG4gICAgfSk7XG5cbiAgICBpZiAoZmlsdGVyZWROb3RpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGluZm8oJycpO1xuICAgICAgaW5mbygnTk9USUNFUyAgICAgICAgIChXaGF0XFwncyB0aGlzPyBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvd2lraS9DTEktTm90aWNlcyknKTtcbiAgICAgIGluZm8oJycpO1xuICAgICAgZm9yIChjb25zdCBmaWx0ZXJlZCBvZiBmaWx0ZXJlZE5vdGljZXMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gZmlsdGVyZWQuZm9ybWF0KCk7XG4gICAgICAgIHN3aXRjaCAoZmlsdGVyZWQubm90aWNlLnNldmVyaXR5KSB7XG4gICAgICAgICAgY2FzZSAnd2FybmluZyc6XG4gICAgICAgICAgICB3YXJuaW5nKGZvcm1hdHRlZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICBlcnJvcihmb3JtYXR0ZWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGluZm8oZm9ybWF0dGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvKCcnKTtcbiAgICAgIH1cbiAgICAgIGluZm8oYElmIHlvdSBkb27igJl0IHdhbnQgdG8gc2VlIGEgbm90aWNlIGFueW1vcmUsIHVzZSBcImNkayBhY2tub3dsZWRnZSA8aWQ+XCIuIEZvciBleGFtcGxlLCBcImNkayBhY2tub3dsZWRnZSAke2ZpbHRlcmVkTm90aWNlc1swXS5ub3RpY2UuaXNzdWVOdW1iZXJ9XCIuYCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2hvd1RvdGFsID8/IGZhbHNlKSB7XG4gICAgICBpbmZvKCcnKTtcbiAgICAgIGluZm8oYFRoZXJlIGFyZSAke2ZpbHRlcmVkTm90aWNlcy5sZW5ndGh9IHVuYWNrbm93bGVkZ2VkIG5vdGljZShzKS5gKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnQge1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByYW5nZSBvZiBhZmZlY3RlZCB2ZXJzaW9uc1xuICAgKi9cbiAgdmVyc2lvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZSB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGlzc3VlTnVtYmVyOiBudW1iZXI7XG4gIG92ZXJ2aWV3OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBIHNldCBvZiBhZmZlY3RlZCBjb21wb25lbnRzXG4gICAqXG4gICAqIFRoZSBjYW5vbmljYWwgZm9ybSBvZiBhIGxpc3Qgb2YgY29tcG9uZW50cyBpcyBpbiBEaXNqdW5jdGl2ZSBOb3JtYWwgRm9ybVxuICAgKiAoaS5lLiwgYW4gT1Igb2YgQU5EcykuIFRoaXMgaXMgdGhlIGZvcm0gd2hlbiB0aGUgbGlzdCBvZiBjb21wb25lbnRzIGlzIGFcbiAgICogZG91Ymx5IG5lc3RlZCBhcnJheTogdGhlIG5vdGljZSBtYXRjaGVzIGlmIGFsbCBjb21wb25lbnRzIG9mIGF0IGxlYXN0IG9uZVxuICAgKiBvZiB0aGUgdG9wLWxldmVsIGFycmF5IG1hdGNoZXMuXG4gICAqXG4gICAqIElmIHRoZSBgY29tcG9uZW50c2AgaXMgYSBzaW5nbGUtbGV2ZWwgYXJyYXksIGl0IGlzIGV2YWx1YXRlZCBhcyBhbiBPUjsgaXRcbiAgICogbWF0Y2hlcyBpZiBhbnkgb2YgdGhlIGNvbXBvbmVudHMgbWF0Y2hlcy5cbiAgICovXG4gIGNvbXBvbmVudHM6IEFycmF5PENvbXBvbmVudCB8IENvbXBvbmVudFtdPjtcbiAgc2NoZW1hVmVyc2lvbjogc3RyaW5nO1xuICBzZXZlcml0eT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBnaXZlbiBjb21wb25lbnRzIHN0cnVjdHVyZSBpbnRvIERORiBmb3JtXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudHMoeHM6IEFycmF5PENvbXBvbmVudCB8IENvbXBvbmVudFtdPik6IENvbXBvbmVudFtdW10ge1xuICByZXR1cm4geHMubWFwKHggPT4gQXJyYXkuaXNBcnJheSh4KSA/IHggOiBbeF0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDb25qdW5jdGlvbih4czogQ29tcG9uZW50W10pOiBzdHJpbmcge1xuICByZXR1cm4geHMubWFwKGMgPT4gYCR7Yy5uYW1lfTogJHtjLnZlcnNpb259YCkuam9pbignIEFORCAnKTtcbn1cblxuLyoqXG4gKiBOb3RpY2UgYWZ0ZXIgcGFzc2luZyB0aGUgZmlsdGVyLiBBIGZpbHRlciBjYW4gYXVnbWVudCBhIG5vdGljZSB3aXRoXG4gKiBkeW5hbWljIHZhbHVlcyBhcyBpdCBoYXMgYWNjZXNzIHRvIHRoZSBkeW5hbWljIG1hdGNoaW5nIGRhdGEuXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJlZE5vdGljZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZHluYW1pY1ZhbHVlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgbm90aWNlOiBOb3RpY2UpIHtcbiAgfVxuXG4gIHB1YmxpYyBhZGREeW5hbWljVmFsdWUoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmR5bmFtaWNWYWx1ZXNbYHtyZXNvbHZlOiR7a2V5fX1gXSA9IHZhbHVlO1xuICB9XG5cbiAgcHVibGljIGZvcm1hdCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvbXBvbmVudHNWYWx1ZSA9IG5vcm1hbGl6ZUNvbXBvbmVudHModGhpcy5ub3RpY2UuY29tcG9uZW50cykubWFwKHJlbmRlckNvbmp1bmN0aW9uKS5qb2luKCcsICcpO1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVEeW5hbWljVmFsdWVzKFtcbiAgICAgIGAke3RoaXMubm90aWNlLmlzc3VlTnVtYmVyfVxcdCR7dGhpcy5ub3RpY2UudGl0bGV9YCxcbiAgICAgIHRoaXMuZm9ybWF0T3ZlcnZpZXcoKSxcbiAgICAgIGBcXHRBZmZlY3RlZCB2ZXJzaW9uczogJHtjb21wb25lbnRzVmFsdWV9YCxcbiAgICAgIGBcXHRNb3JlIGluZm9ybWF0aW9uIGF0OiBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzLyR7dGhpcy5ub3RpY2UuaXNzdWVOdW1iZXJ9YCxcbiAgICBdLmpvaW4oJ1xcblxcbicpICsgJ1xcbicpO1xuICB9XG5cbiAgcHJpdmF0ZSBmb3JtYXRPdmVydmlldygpIHtcbiAgICBjb25zdCB3cmFwID0gKHM6IHN0cmluZykgPT4gcy5yZXBsYWNlKC8oPyFbXlxcbl17MSw2MH0kKShbXlxcbl17MSw2MH0pXFxzL2csICckMVxcbicpO1xuXG4gICAgY29uc3QgaGVhZGluZyA9ICdPdmVydmlldzogJztcbiAgICBjb25zdCBzZXBhcmF0b3IgPSBgXFxuXFx0JHsnICcucmVwZWF0KGhlYWRpbmcubGVuZ3RoKX1gO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB3cmFwKHRoaXMubm90aWNlLm92ZXJ2aWV3KVxuICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcblxuICAgIHJldHVybiAnXFx0JyArIGhlYWRpbmcgKyBjb250ZW50O1xuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlRHluYW1pY1ZhbHVlcyhpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChPYmplY3Qua2V5cyh0aGlzLmR5bmFtaWNWYWx1ZXMpLmpvaW4oJ3wnKSwgJ2cnKTtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZShwYXR0ZXJuLCAobWF0Y2hlZCkgPT4gdGhpcy5keW5hbWljVmFsdWVzW21hdGNoZWRdID8/IG1hdGNoZWQpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlRGF0YVNvdXJjZSB7XG4gIGZldGNoKCk6IFByb21pc2U8Tm90aWNlW10+O1xufVxuXG5leHBvcnQgY2xhc3MgV2Vic2l0ZU5vdGljZURhdGFTb3VyY2UgaW1wbGVtZW50cyBOb3RpY2VEYXRhU291cmNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBTZGtIdHRwT3B0aW9ucztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTZGtIdHRwT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGZldGNoKCk6IFByb21pc2U8Tm90aWNlW10+IHtcbiAgICBjb25zdCB0aW1lb3V0ID0gMzAwMDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHJlcTogQ2xpZW50UmVxdWVzdCB8IHVuZGVmaW5lZDtcblxuICAgICAgbGV0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgICByZXEuZGVzdHJveShuZXcgVG9vbGtpdEVycm9yKCdSZXF1ZXN0IHRpbWVkIG91dCcpKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGltZW91dCk7XG5cbiAgICAgIHRpbWVyLnVucmVmKCk7XG5cbiAgICAgIGNvbnN0IG9wdGlvbnM6IFJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBhZ2VudDogQXdzQ2xpQ29tcGF0aWJsZS5wcm94eUFnZW50KHRoaXMub3B0aW9ucyksXG4gICAgICB9O1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXEgPSBodHRwcy5nZXQoJ2h0dHBzOi8vY2xpLmNkay5kZXYtdG9vbHMuYXdzLmRldi9ub3RpY2VzLmpzb24nLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgcmVzID0+IHtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgIHJlcy5zZXRFbmNvZGluZygndXRmOCcpO1xuICAgICAgICAgICAgICBsZXQgcmF3RGF0YSA9ICcnO1xuICAgICAgICAgICAgICByZXMub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICByYXdEYXRhICs9IGNodW5rO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJhd0RhdGEpLm5vdGljZXMgYXMgTm90aWNlW107XG4gICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcIidub3RpY2VzJyBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGRlYnVnKCdOb3RpY2VzIHJlZnJlc2hlZCcpO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhID8/IFtdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugbm90aWNlczogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9YCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlcy5vbignZXJyb3InLCBlID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IFRvb2xraXRFcnJvcihgRmFpbGVkIHRvIGZldGNoIG5vdGljZXM6ICR7Zm9ybWF0RXJyb3JNZXNzYWdlKGUpfWApKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QobmV3IFRvb2xraXRFcnJvcihgRmFpbGVkIHRvIGZldGNoIG5vdGljZXMuIFN0YXR1cyBjb2RlOiAke3Jlcy5zdGF0dXNDb2RlfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgcmVxLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUb29sa2l0RXJyb3IoYEhUVFBTICdnZXQnIGNhbGwgdGhyZXcgYW4gZXJyb3I6ICR7Zm9ybWF0RXJyb3JNZXNzYWdlKGUpfWApKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgQ2FjaGVkTm90aWNlcyB7XG4gIGV4cGlyYXRpb246IG51bWJlcjtcbiAgbm90aWNlczogTm90aWNlW107XG59XG5cbmNvbnN0IFRJTUVfVE9fTElWRV9TVUNDRVNTID0gNjAgKiA2MCAqIDEwMDA7IC8vIDEgaG91clxuY29uc3QgVElNRV9UT19MSVZFX0VSUk9SID0gMSAqIDYwICogMTAwMDsgLy8gMSBtaW51dGVcblxuZXhwb3J0IGNsYXNzIENhY2hlZERhdGFTb3VyY2UgaW1wbGVtZW50cyBOb3RpY2VEYXRhU291cmNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBmaWxlTmFtZTogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGF0YVNvdXJjZTogTm90aWNlRGF0YVNvdXJjZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNraXBDYWNoZT86IGJvb2xlYW4pIHtcbiAgfVxuXG4gIGFzeW5jIGZldGNoKCk6IFByb21pc2U8Tm90aWNlW10+IHtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gYXdhaXQgdGhpcy5sb2FkKCk7XG4gICAgY29uc3QgZGF0YSA9IGNhY2hlZERhdGEubm90aWNlcztcbiAgICBjb25zdCBleHBpcmF0aW9uID0gY2FjaGVkRGF0YS5leHBpcmF0aW9uID8/IDA7XG5cbiAgICBpZiAoRGF0ZS5ub3coKSA+IGV4cGlyYXRpb24gfHwgdGhpcy5za2lwQ2FjaGUpIHtcbiAgICAgIGNvbnN0IGZyZXNoRGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hJbm5lcigpO1xuICAgICAgYXdhaXQgdGhpcy5zYXZlKGZyZXNoRGF0YSk7XG4gICAgICByZXR1cm4gZnJlc2hEYXRhLm5vdGljZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKGBSZWFkaW5nIGNhY2hlZCBub3RpY2VzIGZyb20gJHt0aGlzLmZpbGVOYW1lfWApO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaElubmVyKCk6IFByb21pc2U8Q2FjaGVkTm90aWNlcz4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHBpcmF0aW9uOiBEYXRlLm5vdygpICsgVElNRV9UT19MSVZFX1NVQ0NFU1MsXG4gICAgICAgIG5vdGljZXM6IGF3YWl0IHRoaXMuZGF0YVNvdXJjZS5mZXRjaCgpLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZyhgQ291bGQgbm90IHJlZnJlc2ggbm90aWNlczogJHtlfWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwaXJhdGlvbjogRGF0ZS5ub3coKSArIFRJTUVfVE9fTElWRV9FUlJPUixcbiAgICAgICAgbm90aWNlczogW10sXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZCgpOiBQcm9taXNlPENhY2hlZE5vdGljZXM+IHtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB7XG4gICAgICBleHBpcmF0aW9uOiAwLFxuICAgICAgbm90aWNlczogW10sXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnMuZXhpc3RzU3luYyh0aGlzLmZpbGVOYW1lKVxuICAgICAgICA/IGF3YWl0IGZzLnJlYWRKU09OKHRoaXMuZmlsZU5hbWUpIGFzIENhY2hlZE5vdGljZXNcbiAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoYEZhaWxlZCB0byBsb2FkIG5vdGljZXMgZnJvbSBjYWNoZTogJHtlfWApO1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNhdmUoY2FjaGVkOiBDYWNoZWROb3RpY2VzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLndyaXRlSlNPTih0aGlzLmZpbGVOYW1lLCBjYWNoZWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKGBGYWlsZWQgdG8gc3RvcmUgbm90aWNlcyBpbiB0aGUgY2FjaGU6ICR7ZX1gKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==